bradleyterry.easy<-function(a,b,id,lambda,dataset){
sumvec<-NULL #create null vectors to store our sum elements
lambdavec<-NULL #create null vector to extract the lambda elements we want
for(i in 1:nrow(dataset[[id]])){ #the purpose of thsi loop is to extract lambda j values for use in the next loop
lambdajsubset<-dataset[[id]]$DocIDj[i] #This picks out the lambda j values for each of the elements of the subset dataset
lambdaj<-lambda[[lambdajsubset]]$Lambda
lambdavec<-c(lambdavec,lambdaj) #this building the vector for use
}
for (i in 1:length(lambdavec)){
sumunit<-(1/(lambda[[id]]$Lambda+lambdavec[i])) #This creates the summation term unit by unit with the lambda i value and all of the respective lambda js
sumvec<-as.vector(c(sumvec,sumunit)) #this makes a vector of the summation terms
}
summationterm<-sum(sumvec) #here we sum the terms of the vector to plug into the equation
output<-(a-1+sum(dataset[[id]]$Choose))/(b+summationterm) #this is where we finish up the equation and plug in all of our respective parts
return(output)
}
bradleyterry<-function(a,b,id,lambda,dataset){
subsetdata<-dataset[dataset$DocIDi %in% id,]#this subsets the dataset down to just the observations with the id that we are looking at
newlambda<-lambda[lambda$DocId %in% id,]#this extracts the specific DocID and lambda value we want to upgrade for the purpose of the equation
sumvec<-NULL #create null vectors to store our sum elements
lambdavec<-NULL #create null vector to extract the lambda elements we want
for(i in 1:nrow(subsetdata)){ #the purpose of thsi loop is to extract lambda j values for use in the next loop
lambdajsubset<-lambda[lambda$DocId %in% subsetdata$DocIDj[i],] #This picks out the lambda j values for each of the elements of the subset dataset
lambdavec<-c(lambdavec,lambdajsubset$Lambda) #this building the vector for use
}
for (i in 1:nrow(subsetdata)){
sumunit<-(1/(newlambda$Lambda+lambdavec[i])) #This creates the summation term unit by unit with the lambda i value and all of the respective lambda js
sumvec<-as.vector(c(sumvec,sumunit)) #this makes a vector of the summation terms
}
summationterm<-sum(sumvec) #here we sum the terms of the vector to plug into the equation
output<-(a-1+sum(subsetdata$Choose))/(b+summationterm) #this is where we finish up the equation and plug in all of our respective parts
return(output)
}
bradleyterry.easy(1,1,4990,test2,test1)
bradleyterry(1,1,4990,HIT2,lambda)
lambda
HIT2
dataset<-HIT2
id<-4990
subsetdata<-dataset[dataset$DocIDi %in% id,]#this subsets the dataset down to just the observations with the id that we are looking at
newlambda<-lambda[lambda$DocId %in% id,]#this extracts the specific DocID and lambda value we want to upgrade for the purpose of the equation
sumvec<-NULL #create null vectors to store our sum elements
lambdavec<-NULL #create null vector to extract the lambda elements we want
for(i in 1:nrow(subsetdata)){ #the purpose of thsi loop is to extract lambda j values for use in the next loop
lambdajsubset<-lambda[lambda$DocId %in% subsetdata$DocIDj[i],] #This picks out the lambda j values for each of the elements of the subset dataset
lambdavec<-c(lambdavec,lambdajsubset$Lambda) #this building the vector for use
}
for (i in 1:nrow(subsetdata)){
sumunit<-(1/(newlambda$Lambda+lambdavec[i])) #This creates the summation term unit by unit with the lambda i value and all of the respective lambda js
sumvec<-as.vector(c(sumvec,sumunit)) #this makes a vector of the summation terms
}
summationterm<-sum(sumvec) #here we sum the terms of the vector to plug into the equation
output<-(a-1+sum(subsetdata$Choose))/(b+summationterm) #this is where we finish up the equation and plug in all of our respective parts
a=1
b=1
output<-(a-1+sum(subsetdata$Choose))/(b+summationterm) #this is where we finish up the equation and plug in all of our respective parts
return(output)
output
bradleyterry<-function(a,b,id,lambda,dataset){
subsetdata<-dataset[dataset$DocIDi %in% id,]#this subsets the dataset down to just the observations with the id that we are looking at
newlambda<-lambda[lambda$DocId %in% id,]#this extracts the specific DocID and lambda value we want to upgrade for the purpose of the equation
sumvec<-NULL #create null vectors to store our sum elements
lambdavec<-NULL #create null vector to extract the lambda elements we want
for(i in 1:nrow(subsetdata)){ #the purpose of thsi loop is to extract lambda j values for use in the next loop
lambdajsubset<-lambda[lambda$DocId %in% subsetdata$DocIDj[i],] #This picks out the lambda j values for each of the elements of the subset dataset
lambdavec<-c(lambdavec,lambdajsubset$Lambda) #this building the vector for use
}
for (i in 1:nrow(subsetdata)){
sumunit<-(1/(newlambda$Lambda+lambdavec[i])) #This creates the summation term unit by unit with the lambda i value and all of the respective lambda js
sumvec<-as.vector(c(sumvec,sumunit)) #this makes a vector of the summation terms
}
summationterm<-sum(sumvec) #here we sum the terms of the vector to plug into the equation
output<-(a-1+sum(subsetdata$Choose))/(b+summationterm) #this is where we finish up the equation and plug in all of our respective parts
return(output)
}
bradleyterry(1,1,4990,HIT2,lambda)
bradleyterry.easy(1,1,4990,test2,test1)
subsetdata<-dataset[dataset$DocIDi %in% id,]#this subsets the dataset down to just the observations with the id that we are looking at
newlambda<-lambda[lambda$DocId %in% id,]#this extracts the specific DocID and lambda value we want to upgrade for the purpose of the equation
sumvec<-NULL #create null vectors to store our sum elements
lambdavec<-NULL #create null vector to extract the lambda elements we want
for(i in 1:nrow(subsetdata)){ #the purpose of thsi loop is to extract lambda j values for use in the next loop
lambdajsubset<-lambda[lambda$DocId %in% subsetdata$DocIDj[i],] #This picks out the lambda j values for each of the elements of the subset dataset
lambdavec<-c(lambdavec,lambdajsubset$Lambda) #this building the vector for use
}
for (i in 1:nrow(subsetdata)){
sumunit<-(1/(newlambda$Lambda+lambdavec[i])) #This creates the summation term unit by unit with the lambda i value and all of the respective lambda js
sumvec<-as.vector(c(sumvec,sumunit)) #this makes a vector of the summation terms
}
summationterm<-sum(sumvec) #here we sum the terms of the vector to plug into the equation
output<-(a-1+sum(subsetdata$Choose))/(b+summationterm) #this is where we finish up the equation and plug in all of our respective parts
output
bradleyterry<-function(a,b,id,lambda,dataset){
subsetdata<-dataset[dataset$DocIDi %in% id,]#this subsets the dataset down to just the observations with the id that we are looking at
newlambda<-lambda[lambda$DocId %in% id,]#this extracts the specific DocID and lambda value we want to upgrade for the purpose of the equation
sumvec<-NULL #create null vectors to store our sum elements
lambdavec<-NULL #create null vector to extract the lambda elements we want
for(i in 1:nrow(subsetdata)){ #the purpose of thsi loop is to extract lambda j values for use in the next loop
lambdajsubset<-lambda[lambda$DocId %in% subsetdata$DocIDj[i],] #This picks out the lambda j values for each of the elements of the subset dataset
lambdavec<-c(lambdavec,lambdajsubset$Lambda) #this building the vector for use
}
for (i in 1:nrow(subsetdata)){
sumunit<-(1/(newlambda$Lambda+lambdavec[i])) #This creates the summation term unit by unit with the lambda i value and all of the respective lambda js
sumvec<-as.vector(c(sumvec,sumunit)) #this makes a vector of the summation terms
}
summationterm<-sum(sumvec) #here we sum the terms of the vector to plug into the equation
output<-(a-1+sum(subsetdata$Choose))/(b+summationterm) #this is where we finish up the equation and plug in all of our respective parts
return(output)
}
bradleyterry(1,1,4990,HIT2,lambda)
HIT2
lambda
bradleyterry.easy(1,1,4990,test2,test1)
bradleyterry(1,1,4990,lambda,HIT2)
bradleyterry.easy(1,1,5015,test2,test1)
bradleyterry(1,1,5015,lambda,HIT2)
bradleyterry.easy<-function(a,b,id,lambda,dataset){
sumvec<-NULL #create null vectors to store our sum elements
lambdavec<-NULL #create null vector to extract the lambda elements we want
for(i in 1:nrow(dataset[[id]])){ #the purpose of thsi loop is to extract lambda j values for use in the next loop
lambdajsubset<-dataset[[id]]$DocIDj[i] #This picks out the lambda j values for each of the elements of the subset dataset
lambdaj<-lambda[[lambdajsubset]]$Lambda
lambdavec<-c(lambdavec,lambdaj) #this building the vector for use
}
for (i in 1:length(lambdavec)){
sumunit<-(1/(lambda[[id]]$Lambda+lambdavec[i])) #This creates the summation term unit by unit with the lambda i value and all of the respective lambda js
sumvec<-as.vector(c(sumvec,sumunit)) #this makes a vector of the summation terms
}
summationterm<-sum(sumvec) #here we sum the terms of the vector to plug into the equation
output<-(a-1+sum(dataset[[id]]$Choose))/(b+summationterm) #this is where we finish up the equation and plug in all of our respective parts
return(output)
}
bradleyterry<-function(a,b,id,lambda,dataset){
subsetdata<-dataset[dataset$DocIDi %in% id,]#this subsets the dataset down to just the observations with the id that we are looking at
newlambda<-lambda[lambda$DocId %in% id,]#this extracts the specific DocID and lambda value we want to upgrade for the purpose of the equation
sumvec<-NULL #create null vectors to store our sum elements
lambdavec<-NULL #create null vector to extract the lambda elements we want
for(i in 1:nrow(subsetdata)){ #the purpose of thsi loop is to extract lambda j values for use in the next loop
lambdajsubset<-lambda[lambda$DocId %in% subsetdata$DocIDj[i],] #This picks out the lambda j values for each of the elements of the subset dataset
lambdavec<-c(lambdavec,lambdajsubset$Lambda) #this building the vector for use
}
for (i in 1:nrow(subsetdata)){
sumunit<-(1/(newlambda$Lambda+lambdavec[i])) #This creates the summation term unit by unit with the lambda i value and all of the respective lambda js
sumvec<-as.vector(c(sumvec,sumunit)) #this makes a vector of the summation terms
}
summationterm<-sum(sumvec) #here we sum the terms of the vector to plug into the equation
output<-(a-1+sum(subsetdata$Choose))/(b+summationterm) #this is where we finish up the equation and plug in all of our respective parts
return(output)
}
microbenchmark(bradleyterry.easy(1,1,5015,test2,test1))
library(microbenchmark)
microbenchmark(bradleyterry.easy(1,1,5015,test2,test1))
microbenchmark(bradleyterry(1,1,5015,lambda,HIT2))
microbenchmark(bradleyterry.easy(1,1,5015,test2,test1),times=1000)
microbenchmark(bradleyterry(1,1,5015,lambda,HIT2)times=1000)
microbenchmark(bradleyterry(1,1,5015,lambda,HIT2),times=1000)
bradleyterry.multid<-function(a, b, id, lambda, dataset){
output<-sapply(id, function(x) bradleyterry(a,b,id=x, lambda, dataset))
output<-cbind(id,output)
output<-as.data.frame(output)
colnames(output)<-c('DocId','Lambda')
return(output)
}
bradleyterry.multide<-function(a, b, id, lambda, dataset){
output<-sapply(id, function(x) bradleyterry.easy(a,b,id=x, lambda, dataset))
output<-cbind(id,output)
output<-as.data.frame(output)
colnames(output)<-c('DocId','Lambda')
return(output)
}
bradleyterry.multid<-function(a, b, id, lambda, dataset){
output<-sapply(id, function(x) bradleyterry(a,b,id=x, lambda, dataset))
output<-cbind(id,output)
output<-as.data.frame(output)
colnames(output)<-c('DocId','Lambda')
return(output)
}
bradleyterry.multide<-function(a, b, id, lambda, dataset){
output<-sapply(id, function(x) bradleyterry.easy(a,b,id=x, lambda, dataset))
output<-cbind(id,output)
output<-as.data.frame(output)
colnames(output)<-c('DocId','Lambda')
return(output)
}
microbenchmark(bradleyterry.multid(1,1,DocId, lambda, HIT2),times=1000)
bradleyterry.multid(1,1,DocId, lambda, HIT2)
bradleyterry.multide(1,1,DocId, test2, test1)
microbenchmark(bradleyterry.multid(1,1,DocId, lambda, HIT2),times=100)
microbenchmark(bradleyterry.multide(1,1,DocId, test2, test1), times=100)
a<-bradleyterry.multid(1,1,DocId, lambda, HIT2)
b<-bradleyterry.multide(1,1,DocId, test2, test1)
cor(a$Lambda,b$Lambda)
plot(a$Lambda,b$Lambda)
bradleyterryeasy<-function(a,b,id,lambda,dataset){
sumvec<-NULL #create null vectors to store our sum elements
lambdavec<-NULL #create null vector to extract the lambda elements we want
for(i in 1:nrow(dataset[[id]])){ #the purpose of thsi loop is to extract lambda j values for use in the next loop
lambdajsubset<-dataset[[id]]$DocIDj[i] #This picks out the lambda j values for each of the elements of the subset dataset
lambdaj<-lambda[[lambdajsubset]]$Lambda
lambdavec<-c(lambdavec,lambdaj) #this building the vector for use
}
for (i in 1:length(lambdavec)){
sumunit<-(1/(lambda[[id]]$Lambda+lambdavec[i])) #This creates the summation term unit by unit with the lambda i value and all of the respective lambda js
sumvec<-as.vector(c(sumvec,sumunit)) #this makes a vector of the summation terms
}
summationterm<-sum(sumvec) #here we sum the terms of the vector to plug into the equation
output<-(a-1+sum(dataset[[id]]$Choose))/(b+summationterm) #this is where we finish up the equation and plug in all of our respective parts
return(output)
}
bradleyterry.multide<-function(a, b, id, lambda, dataset){
output<-sapply(id, function(x) bradleyterryeasy(a,b,id=x, lambda, dataset))
output<-cbind(id,output)
output<-as.data.frame(output)
colnames(output)<-c('DocId','Lambda')
return(output)
}
iterative.bte<-function(a,b,id,lambda,dataset, iterations){
for (i in 1:iterations){   # from 1 to number of iteration, the loop repeats below function
lambda<-bradleyterry.multide(a,b,id,lambda,dataset) #run the code above for one doc id, a number of times determined by user
}
return(lambda) #returns the output as the number of iterations determined by the user.
}
microbenchmark(iterative.bt(1,1,DocId,lambda,HIT2, 50),times=5)
microbenchmark(iterative.bte(1,1,DocId,test2,test1, 50),times=5)
iterative.bte<-function(a,b,id,lambda,dataset, iterations){
for (i in 1:iterations){   # from 1 to number of iteration, the loop repeats below function
lambda<-bradleyterry.multide(a,b,id,lambda,dataset) #run the code above for one doc id, a number of times determined by user
}
return(lambda) #returns the output as the number of iterations determined by the user.
}
microbenchmark(iterative.bte(1,1,DocId,test2,test1, 50),times=5)
iterative.bte(1,1,DocId,test2,test1, 50)
bradleyterry.multide<-function(a, b, id, lambda, dataset){
output<-sapply(id, function(x) bradleyterryeasy(a,b,id=x, lambda, dataset))
output<-cbind(id,output)
output<-as.data.frame(output)
colnames(output)<-c('DocId','Lambda')
return(output)
}
bradleyterryeasy<-function(a,b,id,lambda,dataset){
sumvec<-NULL #create null vectors to store our sum elements
lambdavec<-NULL #create null vector to extract the lambda elements we want
for(i in 1:nrow(dataset[[id]])){ #the purpose of thsi loop is to extract lambda j values for use in the next loop
lambdajsubset<-dataset[[id]]$DocIDj[i] #This picks out the lambda j values for each of the elements of the subset dataset
lambdaj<-lambda[[lambdajsubset]]$Lambda
lambdavec<-c(lambdavec,lambdaj) #this building the vector for use
}
for (i in 1:length(lambdavec)){
sumunit<-(1/(lambda[[id]]$Lambda+lambdavec[i])) #This creates the summation term unit by unit with the lambda i value and all of the respective lambda js
sumvec<-as.vector(c(sumvec,sumunit)) #this makes a vector of the summation terms
}
summationterm<-sum(sumvec) #here we sum the terms of the vector to plug into the equation
output<-(a-1+sum(dataset[[id]]$Choose))/(b+summationterm) #this is where we finish up the equation and plug in all of our respective parts
return(output)
}
bradleyterry.multide<-function(a, b, id, lambda, dataset){
output<-sapply(id, function(x) bradleyterryeasy(a,b,id=x, lambda, dataset))
output<-cbind(id,output)
output<-as.data.frame(output)
colnames(output)<-c('DocId','Lambda')
return(output)
}
iterative.bte<-function(a,b,id,lambda,dataset, iterations){
for (i in 1:iterations){   # from 1 to number of iteration, the loop repeats below function
lambda<-bradleyterry.multide(a,b,id,lambda,dataset) #run the code above for one doc id, a number of times determined by user
}
return(lambda) #returns the output as the number of iterations determined by the user.
}
iterative.bte(1,1,DocId,test2,test1, 50)
iterative.bte(1,1,DocId,test2,test1,5)
iterative.bt(1,1,DocId,lambda,HIT2, 50)
iterative.bte(1,1,DocId,lambda,HIT2, 50)
iterative.bte<-function(a,b,id,lambda,dataset, iterations){
for (i in 1:iterations){   # from 1 to number of iteration, the loop repeats below function
lambda<-bradleyterry.multide(a,b,id,lambda,dataset) #run the code above for one doc id, a number of times determined by user
lambda<-lambdatrans(id,lambda)
}
return(lambda) #returns the output as the number of iterations determined by the user.
}
iterative.bte(1,1,DocId,lambda,HIT2, 50)
bradleyterry.multide(1,1,DocId,test2,test1)
lambda<-bradleyterry.multide(1,1,DocId,test2,test1)
lambda<-lambdatrans(DocId,lambda)
lambda
for (i in 1:5){   # from 1 to number of iteration, the loop repeats below function
lambda<-bradleyterry.multide(a,b,id,lambda,dataset) #run the code above for one doc id, a number of times determined by user
lambda<-lambdatrans(id,lambda)
}
for (i in 1:5){   # from 1 to number of iteration, the loop repeats below function
lambda<-bradleyterry.multide(a,b,id,lambda,dataset) #run the code above for one doc id, a number of times determined by user
lambda<-lambdatrans(id,lambda)
}
bradleyterry.multide<-function(a, b, id, lambda, dataset){
output<-sapply(id, function(x) bradleyterryeasy(a,b,id=x, lambda, dataset))
return(output)
}
bradleyterry.multide(1,1,DocId,test2,test1)
bradleyterry.multide<-function(a, b, id, lambda, dataset){
output<-sapply(id, function(x) bradleyterryeasy(a,b,id=x, lambda, dataset))
return(output)
}
bradleyterry.multide(1,1,DocId,test2,test1)
bradleyterry.multide<-function(a, b, id, lambda, dataset){
output<-sapply(id, function(x) bradleyterryeasy(a,b,id=x, lambda, dataset))
output<-cbind(id,output)
output<-as.data.frame(output)
colnames(output)<-c('DocId','Lambda')
return(output)
}
lambda<-bradleyterry.multide(1,1,DocId,test2,test1)
lambda<-lambdatrans(DocId,lambda)
bradleyterry.multide(1,1,DocId,test2,test1)
for (i in 1:2){   # from 1 to number of iteration, the loop repeats below function
lambda<-bradleyterry.multide(a,b,id,lambda,dataset) #run the code above for one doc id, a number of times determined by user
lambda<-lambdatrans(id,lambda)
}
bradleyterry.multide<-function(a, b, id, lambda, dataset){
output<-sapply(id, function(x) bradleyterryeasy(a,b,id=x, lambda, dataset))
output<-cbind(id,output)
output<-as.data.frame(output)
colnames(output)<-c('DocId','Lambda')
newout<-lambdatrans(id,output)
return(output)
}
iterative.bt<-function(a,b,id,lambda,dataset, iterations){
for (i in 1:iterations){   # from 1 to number of iteration, the loop repeats below function
lambda<-bradleyterry.multide(a,b,id,lambda,dataset) #run the code above for one doc id, a number of times determined by user
}
return(lambda) #returns the output as the number of iterations determined by the user.
}
iterative.bte<-function(a,b,id,lambda,dataset, iterations){
for (i in 1:iterations){   # from 1 to number of iteration, the loop repeats below function
lambda<-bradleyterry.multide(a,b,id,lambda,dataset) #run the code above for one doc id, a number of times determined by user
}
return(lambda) #returns the output as the number of iterations determined by the user.
}
iterative.bt<-function(a,b,id,lambda,dataset, iterations){
for (i in 1:iterations){   # from 1 to number of iteration, the loop repeats below function
lambda<-bradleyterry.multid(a,b,id,lambda,dataset) #run the code above for one doc id, a number of times determined by user
}
return(lambda) #returns the output as the number of iterations determined by the user.
}
iterative.bte(1,1,DocId,test2,test1,3)
garrettmod<-lm(gdp~leftlab+corp+capmob+infl, garrett1998)
library(readr)
garrett1998 <- read_delim("~/Desktop/QPM 1 Rosas/garrett1998.tab", "\t", escape_double = FALSE, trim_ws = TRUE)
garrettmod<-lm(gdp~leftlab+corp+capmob+infl, garrett1998)
stargazer(garrettmod)
library(stargazerx)
library(stargazer)
stargazer(garrettmod)
lmrob(gdp~leftlab+corp+capmob+infl, garrett1998)
library(sandwich)
congress
data(congress
data(congress)
library(datasets)
congress
data(congress)
library(car)
data(congress)
congress
attach(congress)
library(AER)
library(arm)
attach(congress)
data(congress)
congress
library(arm)
data(congress)
congress
library(readr)
March2018_CSV <- read_csv("~/Documents/GitHub/PS7/March2018.CSV.html")
View(March2018_CSV)
library(dplyr)
library(ggplot)
library(ggplot2)
?filter
March2018 <- read_csv("~/Documents/GitHub/PS7/March2018.CSV.html")
march2018 <- read_csv("~/Documents/GitHub/PS7/March2018.CSV.html")
summary(march2018$Description)
filter(march2018, description == "homicide")
read.table("/Users/benjaminschneider/Downloads/congress.txt",header=T)
congress<-read.table("/Users/benjaminschneider/Downloads/congress.txt",header=T)
View(congress)
newcongress<-subset(congress, CONTST94!=0)
newcongress
model<-lm(DVOTE94~DVOTE92+DWIN92,newcongress)
stargazer(model)
plot(residuals(model))
lm(DVOTE94~DVOTE92+DWIN92+factor(STATE),newcongress)
summary(lm(DVOTE94~DVOTE92+DWIN92+factor(STATE),newcongress))
fixedmod<-lm(DVOTE94~DVOTE92+DWIN92+factor(STATE),newcongress)
stargazer(model,fixedmod)
n <- nrow(model.matrix(garrettmod)) #number of rows (observations)
k <- ncol(model.matrix(garrettmod))
se.r <- as.matrix(coeftest(garrettmod, n/(n-k)*sandwich(garrettmod)))[,2] #robust standard errors
library(sandwich)
se.r <- as.matrix(coeftest(garrettmod, n/(n-k)*sandwich(garrettmod)))[,2] #robust standard errors
library(sandwich)
library(lmtest)
n <- nrow(model.matrix(garrettmod)) #number of rows (observations)
k <- ncol(model.matrix(garrettmod))
se.r <- as.matrix(coeftest(garrettmod, n/(n-k)*sandwich(garrettmod)))[,2] #robust standard errors
car::ncvTest(garrettmod) #not heteroskedasticity
plot(garrettmod$residuals, garrettmod$fitted.values) # no correlation between residuals
se.r
cbind(garrettmod$residuals,se.r)
se.r
stargazer(garrettmod,garretmod)
stargazer(garrettmod,garreTtmod)
stargazer(garrettmod,garrettmod)
se.r
car::ncvTest(garrettmod) #not heteroskedasticity
plot(garrettmod$residuals, garrettmod$fitted.values, main="Check of Residuals vs Fitted Values") # no correlation between residuals
library(pcse)
library(pcse)
dat<-cbind(1:25,runif(25))
set.seed(5)
dat<-cbind(1:25,runif(25))
dat<-as.data.frame(dat)
colnames(dat)<-c("Y","X")
lm(Y~X,dat)
plot(dat$X,dat$Y)
abline(-1.513,13.742)
plot(dat$Y,dat$X)
abline(-1.513,13.742)
set.seed(5)
dat<-cbind(1:25,runif(25))
dat<-as.data.frame(dat)
colnames(dat)<-c("X","Y")
lm(Y~X,dat)
plot(dat$Y,dat$X)
plot(dat$X,dat$Y)
abline(-0.002328,0.520727)
abline(0.520727,-0.002328)
plot(dat$X,dat$Y)
abline(0.520727,-0.002328)
set.seed(5)
dat<-cbind(1:100,runif(100))
dat<-as.data.frame(dat)
colnames(dat)<-c("X","Y")
lm(Y~X,dat)
plot(dat$X,dat$Y)
dat<-cbind(1:50,2:51)
dat<-as.data.frame(dat)
colnames(dat)<-c("X","Y")
lm(Y~X,dat)
plot(dat$X,dat$Y)
abline(1,1,col="red")
summary(march2018$Description)
filter(march2018, description %>% "homicide")
filter(march2018, Description %>% "homicide")
dat<-cbind(1:50,2:51)
x<-1:50
treatment<-sample(c(0,1), 50, replace = TRUE, prob = c(.5,.5))
for (i in length(x)){
if (treatment==1){
y<-x*2
}
else {
y<-x
}
}
y
for (i in length(x)){
if (treatment[i]==1){
y<-x+2
}
else {
`y<-x
}
}
y
for (i in length(x)){
if (treatment[i]==1){
y<-x+2
}
else {
y<-x
}
}
y
for (i in length(x)){
if (treatment[i]==1){
y<-x+2
}
else {
y<-x
}
}
for (i in 1:length(x)){
if (treatment[i]==1){
y<-x+2
}
else {
y<-x
}
}
y
for (i in 1:length(x)){
if (treatment[i]==1){
y<-x+2}
else {
y<-x}
}
y
dat<-as.data.frame(dat)
colnames(dat)<-c("X","Y")
lm(Y~X,dat)
plot(dat$X,dat$Y)
abline(1,1,col="red")
