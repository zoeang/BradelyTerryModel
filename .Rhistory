lower <- curve(-.4 -.9*x + .02*x^2, -1,6, add=T, lty=2, col="red")
polygon(c(upper$x, lower$x[length(lower$x):1]), c(upper$y, lower$y[length(lower$y):1]), col=rgb(1,0,0,alpha=.1), border=F)
plot(lm1.fix$fitted,lm1.fix$residuals, pch=16, xlab="Fitted Values", ylab="Residuals",main="Fitted vs Residuals, Altered Model")
plot(lm1,2, pch=16, main="Q-Q Plot, Author's Model", caption="")
plot(lm1.fix,2, pch=16,main="Q-Q Plot, Altered Model", caption="")
plot(dat$lnpop,lm1$residuals, pch=16, xlab="Log Population", ylab="Residuals", main="Population vs Residuals, Author's Model", cex=.75, ylim=c(-5,11))
upper <- curve(-2.8+ -.14*x + .03*x^2, 11,22, add=T, lty=2, col="red")
lower <- curve(0 +.14*x - .015*x^2, 11,22, add=T, lty=2, col="red")
polygon(c(upper$x, lower$x[length(lower$x):1]), c(upper$y, lower$y[length(lower$y):1]), col=rgb(1,0,0,alpha=.1), border=F)
plot(dat$lnpop[as.numeric(names(lm1.fix$residuals))],lm1.fix$residuals, pch=16, xlab="Log Population", ylab="Residuals",main="Population vs Residuals, Altered Model", cex=.75)
y.loess <- loess(lm1.fix$residuals ~ dat$lnpop[as.numeric(names(lm1.fix$residuals))])
freq <- hist(dat$multish, main="Multilataral Aid Flows", xlab="Multilateral Aid Flows", col="red", breaks=100, plot=F)
plot(freq,main="Original", xlab="Multilateral Aid Flows", col="red", breaks=100)
hist(dat$transform, main="Transformed", xlab="Multilateral Aid Flows", col="red", breaks=100)
ll.normal <- function(par,y,X){
beta <- par[1:ncol(X)]
sigma2 <- exp(par[ncol(X)+1])
-1/2 * (sum(log(sigma2) + (y -(X%*%beta))^2/sigma2))
}
freq <- hist(dat$multish, main="Multilataral Aid Flows", xlab="Multilateral Aid Flows", col="red", breaks=100, plot=F)
plot(freq,main="Original", xlab="Multilateral Aid Flows", col="red", breaks=100) #plot the pre-transformed historgram
hist(dat$transform, main="Transformed", xlab="Multilateral Aid Flows", col="red", breaks=100) #plot the post-transformed histogram (lambda = .18)
plot(se.nr.fix-se.r.fix, seq(1,length(se.r.fix)), xlim=c(-2.2,2), col=rgb(0,0,1,alpha=.75), pch=16, xlab="Regular SE's - Robust SE's", ylab="", axes=F)
points(se.nr-se.r, seq(1,length(se.r)),col=rgb(1,0,0,alpha=.75), pch=16)
lines(c(0,0), c(0,length(se.r)+1), lty=2)
axis(1)
axis(2, at=1:length(se.r.fix), labels=names(lm1$coefficients), las=1, cex.axis=.8)
text(-1.8,1.5, "Author's Model", col="red")
text(.5,2, "Altered Model", col="blue")
plot(lm1$fitted,lm1$residuals, pch=16, xlab="Fitted Values", ylab="Residuals", main="Fitted vs Residuals, Author's Model", ylim=c(-5,11), cex=.75)
upper <- curve(1.5+.6*x + .2*x^2, -1,6, add=T, lty=2, col="red")
lower <- curve(-.4 -.9*x + .02*x^2, -1,6, add=T, lty=2, col="red")
polygon(c(upper$x, lower$x[length(lower$x):1]), c(upper$y, lower$y[length(lower$y):1]), col=rgb(1,0,0,alpha=.1), border=F)
plot(lm1.fix$fitted,lm1.fix$residuals, pch=16, xlab="Fitted Values", ylab="Residuals",main="Fitted vs Residuals, Altered Model")
plot(lm1,2, pch=16, main="Q-Q Plot, Author's Model", caption="")
plot(lm1.fix,2, pch=16,main="Q-Q Plot, Altered Model", caption="")
plot(dat$lnpop,lm1$residuals, pch=16, xlab="Log Population", ylab="Residuals", main="Population vs Residuals, Author's Model", cex=.75, ylim=c(-5,11))
upper <- curve(-2.8+ -.14*x + .03*x^2, 11,22, add=T, lty=2, col="red")
lower <- curve(0 +.14*x - .015*x^2, 11,22, add=T, lty=2, col="red")
polygon(c(upper$x, lower$x[length(lower$x):1]), c(upper$y, lower$y[length(lower$y):1]), col=rgb(1,0,0,alpha=.1), border=F)
plot(dat$lnpop[as.numeric(names(lm1.fix$residuals))],lm1.fix$residuals, pch=16, xlab="Log Population", ylab="Residuals",main="Population vs Residuals, Altered Model", cex=.75)
y.loess <- loess(lm1.fix$residuals ~ dat$lnpop[as.numeric(names(lm1.fix$residuals))])
freq <- hist(dat$multish, main="Multilataral Aid Flows", xlab="Multilateral Aid Flows", col="red", breaks=100, plot=F)
plot(freq,main="Original", xlab="Multilateral Aid Flows", col="red", breaks=100)
hist(dat$transform, main="Transformed", xlab="Multilateral Aid Flows", col="red", breaks=100)
par(mfrow=c(2,2))
freq <- hist(dat$multish, main="Multilataral Aid Flows", xlab="Multilateral Aid Flows", col="red", breaks=100, plot=F)
plot(freq,main="Original", xlab="Multilateral Aid Flows", col="red", breaks=100)
hist(dat$transform, main="Transformed", xlab="Multilateral Aid Flows", col="red", breaks=100)
par(mfrow=c(1,2))
freq <- hist(dat$multish, main="Multilataral Aid Flows", xlab="Multilateral Aid Flows", col="red", breaks=100, plot=F)
plot(freq,main="Original", xlab="Multilateral Aid Flows", col="red", breaks=100)
hist(dat$transform, main="Transformed", xlab="Multilateral Aid Flows", col="red", breaks=100)
plot(lm1$fitted,lm1$residuals, pch=16, xlab="Fitted Values", ylab="Residuals", main="Fitted vs Residuals, Author's Model", ylim=c(-5,11), cex=.75)
upper <- curve(1.5+.6*x + .2*x^2, -1,6, add=T, lty=2, col="red")
lower <- curve(-.4 -.9*x + .02*x^2, -1,6, add=T, lty=2, col="red")
polygon(c(upper$x, lower$x[length(lower$x):1]), c(upper$y, lower$y[length(lower$y):1]), col=rgb(1,0,0,alpha=.1), border=F)
plot(lm1.fix$fitted,lm1.fix$residuals, pch=16, xlab="Fitted Values", ylab="Residuals",main="Fitted vs Residuals, Altered Model")
plot(lm1,2, pch=16, main="Q-Q Plot, Author's Model", caption="")
plot(lm1.fix,2, pch=16,main="Q-Q Plot, Altered Model", caption="")
plot(lm1$fitted,lm1$residuals, pch=16, xlab="Fitted Values", ylab="Residuals", main="Fitted vs Residuals, Author's Model", ylim=c(-5,11), cex=.75)
upper <- curve(1.5+.6*x + .2*x^2, -1,6, add=T, lty=2, col="red")
lower <- curve(-.4 -.9*x + .02*x^2, -1,6, add=T, lty=2, col="red")
polygon(c(upper$x, lower$x[length(lower$x):1]), c(upper$y, lower$y[length(lower$y):1]), col=rgb(1,0,0,alpha=.1), border=F)
plot(lm1.fix$fitted,lm1.fix$residuals, pch=16, xlab="Fitted Values", ylab="Residuals",main="Fitted vs Residuals, Altered Model")
plot(lm1,2, pch=16, main="Q-Q Plot, Author's Model", caption="")
plot(lm1.fix,2, pch=16,main="Q-Q Plot, Altered Model", caption="")
plot(dat$lnpop,lm1$residuals, pch=16, xlab="Log Population", ylab="Residuals", main="Population vs Residuals, Author's Model", cex=.75, ylim=c(-5,11))
par(mfrow=c(2,2))
plot(lm1$fitted,lm1$residuals, pch=16, xlab="Fitted Values", ylab="Residuals", main="Fitted vs Residuals, Author's Model", ylim=c(-5,11), cex=.75)
plot(lm1.fix$fitted,lm1.fix$residuals, pch=16, xlab="Fitted Values", ylab="Residuals",main="Fitted vs Residuals, Altered Model")
plot(lm1,2, pch=16, main="Q-Q Plot, Author's Model", caption="")
plot(lm1.fix$fitted,lm1.fix$residuals, pch=16, xlab="Fitted Values", ylab="Residuals",main="Fitted vs Residuals, Altered Model")
par(mfrow=c(2,2))
plot(lm1$fitted,lm1$residuals, pch=16, xlab="Fitted Values", ylab="Residuals", main="Fitted vs Residuals, Author's Model", ylim=c(-5,11), cex=.75)
plot(lm1.fix$fitted,lm1.fix$residuals, pch=16, xlab="Fitted Values", ylab="Residuals",main="Fitted vs Residuals, Altered Model")
plot(lm1,2, pch=16, main="Q-Q Plot, Author's Model", caption="")
plot(lm1.fix,2, pch=16,main="Q-Q Plot, Altered Model", caption="")
par(mfrow=c(2,2))
plot(lm1$fitted,lm1$residuals, pch=16, xlab="Fitted Values", ylab="Residuals", main="Fitted vs Residuals, Author's Model", ylim=c(-5,11), cex=.75)
plot(lm1,2, pch=16, main="Q-Q Plot, Author's Model", caption="")
plot(lm1.fix$fitted,lm1.fix$residuals, pch=16, xlab="Fitted Values", ylab="Residuals",main="Fitted vs Residuals, Altered Model")
plot(lm1.fix,2, pch=16,main="Q-Q Plot, Altered Model", caption="")
plot(lm1,2, pch=16, main="Q-Q Plot, Author's Model", caption="")#Neumayer's Q-Q plot does not imply normality of errors (pg 172, FIg 6)
plot(lm1.fix,2, pch=16,main="Q-Q Plot, Altered Model", caption="")#King and Robetss Q-Q plot does imply normality of errors (pg 172, FIg 6)
plot(dat$lnpop,lm1$residuals, pch=16, xlab="Log Population", ylab="Residuals", main="Population vs Residuals, Author's Model", cex=.75, ylim=c(-5,11))
plot(dat$lnpop,lm1$residuals, pch=16, xlab="Log Population", ylab="Residuals", main="Population vs Residuals, Author's Model", cex=.75, ylim=c(-5,11))
plot(dat$lnpop,lm1$residuals, pch=16, xlab="Log Population", ylab="Residuals", main="Population vs Residuals, Author's Model", cex=.75, ylim=c(-5,11))
upper <- curve(-2.8+ -.14*x + .03*x^2, 11,22, add=T, lty=2, col="red") #upper envelope
lower <- curve(0 +.14*x - .015*x^2, 11,22, add=T, lty=2, col="red") #lower envelope
polygon(c(upper$x, lower$x[length(lower$x):1]), c(upper$y, lower$y[length(lower$y):1]), col=rgb(1,0,0,alpha=.1), border=F) #color in the envelope
plot(dat$lnpop[as.numeric(names(lm1.fix$residuals))],lm1.fix$residuals, pch=16, xlab="Log Population", ylab="Residuals",main="Population vs Residuals, Altered Model", cex=.75)
par(mfrow=c(2,2))
plot(dat$lnpop,lm1$residuals, pch=16, xlab="Log Population", ylab="Residuals", main="Population vs Residuals, Author's Model", cex=.75, ylim=c(-5,11))
plot(lm1,2, pch=16, main="Q-Q Plot, Author's Model", caption="")
plot(dat$lnpop[as.numeric(names(lm1.fix$residuals))],lm1.fix$residuals, pch=16, xlab="Log Population", ylab="Residuals",main="Population vs Residuals, Altered Model", cex=.75)
plot(lm1.fix,2, pch=16,main="Q-Q Plot, Altered Model", caption="")
y.loess <- loess(lm1.fix$residuals ~ dat$lnpop[as.numeric(names(lm1.fix$residuals))])
freq <- hist(dat$multish, main="Multilataral Aid Flows", xlab="Multilateral Aid Flows", col="red", breaks=100, plot=F)
plot(freq,main="Original", xlab="Multilateral Aid Flows", col="red", breaks=100) #plot the pre-transformed historgram
hist(dat$transform, main="Transformed", xlab="Multilateral Aid Flows", col="red", breaks=100) #plot the post-transformed histogram (lambda = .18)
ll.normal <- function(par,y,X){
beta <- par[1:ncol(X)]
sigma2 <- exp(par[ncol(X)+1])
-1/2 * (sum(log(sigma2) + (y -(X%*%beta))^2/sigma2))
}
it <- seq(11,16, by=.1)
save <- matrix(ncol=3, nrow=length(it))
for(i in 1:length(it)){
betas <- mvrnorm(10000, lm1$coefficients, n/(n-k)*sandwich(lm1))
covs <- apply(model.matrix(lm1),2,mean)
#Regular
covs[2] <- it[i]
covs[3] <- covs[2]^2
mu.at.mean <- covs%*%t(betas)
save[i,] <- c(mean(mu.at.mean), quantile(mu.at.mean,.025), quantile(mu.at.mean,.975))
}
plot(it, save[,1])
X <- model.matrix(lm1.fix)
y <- na.omit(dat$transform)
opt1 <- optim(par = rep(0, ncol(X) + 1), fn = ll.normal, y = y,
X = X, control = list(fnscale = -1), method = "BFGS", hessian = TRUE)
it <- seq(11,16, by=.1)
save2 <- matrix(ncol=3, nrow=length(it))
for(i in 1:length(it)){
betas <- mvrnorm(10000, opt1$par, solve(-opt1$hessian))
covs <- apply(model.matrix(lm1.fix),2,mean)
#Regular
covs[2] <- it[i]
covs[3] <- covs[2]^2
mu.at.mean <- covs%*%t(betas[,1:(ncol(betas)-1)])
params <- cbind(drop(mu.at.mean), exp(betas[,ncol(betas)]))
#untransformed y
y <- apply(params,1, function (x) rnorm(1000, x[1], x[2]))
#transformed y
y <- (y*.18 +1)^(1/.18)
print(paste(i, "out of", length(it)))
#save2[i,] <- c(mean(as.vector(y)), quantile(as.vector(y), .025), quantile(as.vector(y), .975))
save2[i,] <- c(mean(apply(y,2,mean, na.rm=T)), quantile(apply(y,2,mean, na.rm=T),.025), quantile(apply(y,2,mean, na.rm=T),.975))
}
election_results_2016 <- read_csv("~/Downloads/election_results_2016.csv")
countydata <- read_csv("~/Desktop/QPM 1 Rosas/abs-jop-countydata.csv")
library(readr)
election_results_2016 <- read_csv("~/Downloads/election_results_2016.csv")
countydata <- read_csv("~/Desktop/QPM 1 Rosas/abs-jop-countydata.csv")
merge?
?merge
?merge
View(countydata)
View(election_results_2016)
name(election_results_2016$county_fips_code)<-"fips"
election_results_2016$fips<-election_results_2016$county_fips_code
election_results_2016$fips<-election_results_2016$county_fips_code
merge(countydata, election_results_2016, by=fips)
merge(countydata, election_results_2016, by="fips")
metadat<-merge(countydata, election_results_2016, by="fips")
View(metadat)
metadat$dem_2016
metadat$trump.vote.share<-metadat$gop_2016/(metadat$gop_2016+metadat$dem_2016)
lm(trump.vote.share~pslave1860,metadat)
basicmod<-lm(trump.vote.share~pslave1860+factor(state.abb)+blkprop2010,metadat)
stargazer(basicmod)
library(stargazer)
stargazer(basicmod)
log(1596)
basicmod<-lm(trump.vote.share~pslave1860,metadat)
covmod<-lm(trump.vote.share~pslave1860+totpop1860+sfarmprop1860+land.ineq1860+fvalpc1860+acimp1860+fbprop1860+rail1860+water1860+log(coarea)+rugged+longitude+latitude+blkprop2010,metadat)
fixedmod<-lm(trump.vote.share~pslave1860+totpop1860+sfarmprop1860+land.ineq1860+fvalpc1860+acimp1860+fbprop1860+rail1860+water1860+log(coarea)+rugged+longitude+latitude+factor(state.abb)+blkprop2010,metadat)
stargazer(basicmod,covmod,fixedmod)
base.iv.form <- Formula(. ~ pslave1860 + log(coarea00) + rugged + latitude + I(latitude^2) + longitude + I(longitude^2)  + water1860  + state.abb | cottonsuit + log(coarea00) + rugged  + latitude + I(latitude^2) + longitude + I(longitude^2) + water1860  + state.abb)
library(Formula)
base.iv.form <- Formula(. ~ pslave1860 + log(coarea00) + rugged + latitude + I(latitude^2) + longitude + I(longitude^2)  + water1860  + state.abb | cottonsuit + log(coarea00) + rugged  + latitude + I(latitude^2) + longitude + I(longitude^2) + water1860  + state.abb)
cnty.iv <- ivreg(update(base.iv.form, trump.vote.share ~ .), data = south.counties, weights = sample.size)
library(Formula)
base.iv.form <- Formula(. ~ pslave1860 + log(coarea00) + rugged + latitude + I(latitude^2) + longitude + I(longitude^2)  + water1860  + state.abb | cottonsuit + log(coarea00) + rugged  + latitude + I(latitude^2) + longitude + I(longitude^2) + water1860  + state.abb)
cnty.iv <- ivreg(update(base.iv.form, trump.vote.share ~ .), data = south.counties, weights = sample.size)
library(Formula)
library(AER)
base.iv.form <- Formula(. ~ pslave1860 + log(coarea00) + rugged + latitude + I(latitude^2) + longitude + I(longitude^2)  + water1860  + state.abb | cottonsuit + log(coarea00) + rugged  + latitude + I(latitude^2) + longitude + I(longitude^2) + water1860  + state.abb)
cnty.iv <- ivreg(update(base.iv.form, trump.vote.share ~ .), data = south.counties, weights = sample.size)
cnty.iv <- ivreg(update(base.iv.form, trump.vote.share ~ .), data = metadat, weights = sample.size)
cnty.iv <- ivreg(update(base.iv.form, trump.vote.share ~ .), data = metadat)
summary(cnty.iv)
base.iv.form
firststage<-lm(pslave1860~cottonsuit + log(coarea00) + rugged + latitude + I(latitude^2) + longitude + I(longitude^2)  + water1860  + state.abb | cottonsuit + log(coarea00) + rugged  + latitude + I(latitude^2) + longitude + I(longitude^2) + water1860  + state.abb, metadat)
base.iv.form <- Formula(. ~ pslave1860 + log(coarea00) + rugged + latitude + I(latitude^2) + longitude + I(longitude^2)  + water1860  + state.abb | cottonsuit + log(coarea00) + rugged  + latitude + longitude + water1860  + state.abb)
cnty.iv <- ivreg(update(base.iv.form, trump.vote.share ~ .), data = metadat)
firststage<-lm(pslave1860~cottonsuit + log(coarea00) + rugged + latitude + I(latitude^2) + longitude + I(longitude^2)  + water1860  + state.abb | cottonsuit + log(coarea00) + rugged  + latitude + longitude + water1860  + state.abb, metadat)
cnty.iv <- ivreg(update(base.iv.form, trump.vote.share ~ .), data = metadat)
base.iv.form <- Formula(. ~ pslave1860 + log(coarea00) + rugged + latitude + I(latitude^2) + longitude + I(longitude^2)  + water1860  + state.abb | cottonsuit + log(coarea00) + rugged  + latitude + I(latitude^2) + longitude + I(longitude^2) + water1860  + state.abb)
cnty.iv <- ivreg(update(base.iv.form, trump.vote.share ~ .), data = metadat)
firststage<-lm(pslave1860~cottonsuit + log(coarea00) + rugged + latitude + I(latitude^2) + longitude + I(longitude^2)  + water1860  + state.abb, metadat)
trump.iv <- ivreg(update(base.iv.form, trump.vote.share ~ .), data = metadat)
firststage<-lm(pslave1860~cottonsuit + log(coarea00) + rugged + latitude + I(latitude^2) + longitude + I(longitude^2)  + water1860  + state.abb, metadat)
stargazer(firststage,trump.iv)
base.iv.form <- Formula(. ~ pslave1860 + log(coarea00) + rugged + latitude + I(latitude^2) + longitude + I(longitude^2)  + water1860  + state.abb | cottonsuit + log(coarea00) + rugged  + latitude + I(latitude^2) + longitude + I(longitude^2) + water1860  + state.abb)
base.first.form <- formula(pslave1860 ~ cottonsuit + log(coarea00) + rugged + latitude + I(latitude^2) + longitude + I(longitude^2)  +water1860 + state.abb)
cnty.res.first <- lm(base.first.form, data = metadat)
summary(cnty.res.first)
cnty.iv <- ivreg(update(base.iv.form, trump.vote.share ~ .), data = south.counties, weights = sample.size)
cnty.aff.iv <- ivreg(update(base.iv.form, affirm  ~ .), data = metadat, weights = sample.size)
summary(cnty.aff.iv)
cnty.iv <- ivreg(update(base.iv.form, trump.vote.share ~ .), data = south.counties, weights = sample.size)
cnty.iv <- ivreg(update(base.iv.form, trump.vote.share ~ .), data = metadat, weights = sample.size)
cnty.iv <- ivreg(update(base.iv.form, trump.vote.share ~ .), data = metadat)
summary(cnty.iv)
base.iv.form <- Formula(. ~ pslave1860 + log(coarea00) + rugged + latitude + I(latitude^2) + longitude + I(longitude^2)  + water1860  + state.abb | cottonsuit + log(coarea00) + rugged  + latitude + I(latitude^2) + longitude + I(longitude^2) + water1860  + state.abb)
base.first.form <- formula(pslave1860 ~ cottonsuit + log(coarea00) + rugged + latitude + I(latitude^2) + longitude + I(longitude^2)  +water1860 + state.abb)
rform.form <- formula(. ~  cottonsuit + log(coarea00) + rugged + latitude + I(latitude^2)+ longitude + I(longitude^2)  + water1860+  state.abb)
cnty.iv <- ivreg(update(base.iv.form, trump.vote.share ~ .), data = metadat)
summary(cnty.iv)
cnty.res.first <- lm(base.first.form, data = metadat)
summary(cnty.res.first)
stargazer(cnty.res.first,cnty.iv)
model<-lm(cottonsuit~pslave1860,countydata)
mean(model$residuals)
mean(model$residuals)
plot(model$residuals,model$fitted.values)
model<-lm(pslave1860~cottonsuit,countydata)
mean(model$residuals)
plot(model$residuals,model$fitted.values)
plot(model$fitted.values,model$residuals)
abline(0,col="red")
abline(0,0,col="red")
plot(model$fitted.values,model$residuals, main="Residuals vs Fitted Data")
plot(model$fitted.values,model$residuals, main="Residuals vs Fitted Values")
abline(0,0,col="red")
model<-lm(pslave1860~cottonsuit+log(coarea00)+rugged+latitude+I(latitude^2)+longitude+I(longitude^2)+water1860+state.abb, countydata)
mean(model$residuals)
plot(model$fitted.values,model$residuals, main="Residuals vs Fitted Values")
abline(0,0,col="red")
mean(model$residuals)
plot(model$fitted.values,model$residuals, main="Residuals vs Fitted Values")
abline(0,0,col="red")
mean(pslave1860)
mean(countrydata$pslave1860)
mean(countydata$pslave1860)
countydata$pslave1860
valvec<-NULL
for (i in 1:length(vals)){
if (vals[i]>0){
valvec<-c(valvec,vals[i])
}
}
vals<-countydata$pslave1860
valvec<-NULL
for (i in 1:length(vals)){
if (vals[i]>0){
valvec<-c(valvec,vals[i])
}
}
for (i in 1:length(vals)){
if (vals[i]>0==T){
valvec<-c(valvec,vals[i])
}
}
(vals[i]>0)
vals[2]>0
vals<-countydata$pslave1860
valvec<-NULL
for (i in 1:length(vals)){
if ((vals[i]>0)==T){
valvec<-c(valvec,vals[i])
}
else{
1}
}
valvec
vals<-countydata$pslave1860
vals<-na.omit(vals)
valvec<-NULL
for (i in 1:length(vals)){
if ((vals[i]>0)==T){
valvec<-c(valvec,vals[i])
}
else{
1}
}
mean(vals)
plot(model$fitted.values,model$residuals, main="Residuals vs Fitted Values",xlim=c(limit,.7))
limit<-mean(vals)
plot(model$fitted.values,model$residuals, main="Residuals vs Fitted Values",xlim=c(limit,.7))
abline(0,0,col="red")
plot(model$fitted.values,model$residuals, main="Residuals vs Fitted Values",xlim=c(limit,64))
plot(model$fitted.values,model$residuals, main="Residuals vs Fitted Values",xlim=c(limit,.64))
abline(0,0,col="red")
rm(list=ls())
dat<-read.csv("/Users/benjaminschneider/Documents/GitHub/BradelyTerryModel/CombinedOutputExperiment2.csv", header = T)
HIT<-dat[,3:5]
HIT<-read.csv("/Users/benjaminschneider/Documents/GitHub/BradelyTerryModel/exampleHITs.csv", header=T)
HIT<-read.csv("C:/Users/dell/Documents/GitHub/BradelyTerryModel/exampleHITs.csv", header=T)
datatransform<-function(HIT){
vec<-rep(1:2, 1500)
HIT<-as.data.frame(cbind(HIT,vec))
colnames(HIT)<-c("comparison_id" ,"document_id", "result","num")
DocIDi<-NULL
DocIDj<-NULL
Choose<-NULL
for (i in 1:nrow(HIT)){
if (HIT$num[i]==2){
DocIDj<-c(DocIDj,HIT$document_id[i])
}
else{
DocIDi<-c(DocIDi,HIT$document_id[i])
Choose<-c(Choose,HIT$result[i])
}
}
newHIT<-as.data.frame(cbind(DocIDi,DocIDj,Choose))
DocIDi<-NULL
DocIDj<-NULL
Choose<-NULL
for (i in 1:nrow(HIT)){
if (HIT$num[i]==1){
DocIDj<-c(DocIDj,HIT$document_id[i])
}
else{
DocIDi<-c(DocIDi,HIT$document_id[i])
Choose<-c(Choose,HIT$result[i])
}
}
newHIT2<-as.data.frame(cbind(DocIDi,DocIDj,Choose))
metaHIT<-rbind(newHIT,newHIT2)
return(metaHIT)
}
HIT2<-datatransform(HIT)
set.seed(42)
DocId<-unique(HIT$document_id)
DocId<-sort(DocId, decreasing = F)
Lambda<-runif(50)
lambda<-cbind(DocId,Lambda)
lambda<-as.data.frame(lambda)
data.generation<-function(lambda,n){ #n size dataset
output.lambda<-NULL #creates a template for the output dataset
for (i in 1:n){#this is a for loop for creating data points, n size dataset
lams<-sample(lambda$DocId, 2)#this randomly selects two of the lambdas at random
lambdavec<-NULL #creates a templace for extracting the lambda values
for (i in lams){
lambdavec<-c(lambdavec,lambda$Lambda[i]) #this actually extracts the lambdas
}
prob<-lambdavec[1]/(lambdavec[1]+lambdavec[2]) #this uses the lambdas in order to create a probability for selection
Choose <- sample(c(0,1), 1, replace = TRUE, prob = c(1-prob, prob))#this chooses the document with the predetermined probability
new.lambda<-cbind(lams[1],lams[2],Choose) #now building our output
output.lambda<-rbind(output.lambda, new.lambda)#row binding with the template
}
rownames(output.lambda)<-NULL #getting rid of the numbers for row name
output.lambda<-as.data.frame(output.lambda) #we do this because removing our row names made a sort of matrix
colnames(output.lambda)<-c("DocIDi","DocIDj","Choose") #Making the output like our dataset
return(output.lambda) #outputs our data
}
dataset<-data.generation(lambda,500)
head(HIT2)
datatrans<-function(docid,dat){
outputlist<-NULL
outputlist<-as.list(outputlist)
for (i in docid){
outputlist[[i]]<-dat[dat$DocIDi %in% i,]
}
return(outputlist)
}
test1<-datatrans(DocId,HIT2)
test1[[5000]]
lambdatrans<-function(docid,lambda){
lambdalist<-NULL
lambdalist<-as.list(lambdalist)
for (i in docid){
lambdalist[[i]]<-lambda[lambda$DocId %in% i,]
}
return(lambdalist)
}
head(lambda)
test2<-lambdatrans(DocId,lambda)
test2[[4990]][,2]
class(test2)
bradleyterryeasy<-function(a,b,id,lambda,dat){
sumvec<-NULL #create null vectors to store our sum elements
lambdavec<-NULL #create null vector to extract the lambda elements we want
for(i in 1:nrow(dat[[id]])){ #the purpose of thsi loop is to extract lambda j values for use in the next loop
lambdajsubset<-dat[[id]]$DocIDj[i] #This picks out the lambda j values for each of the elements of the subset dataset
lambdaj<-lambda[[lambdajsubset]]$Lambda
lambdavec<-c(lambdavec,lambdaj) #this building the vector for use
}
for (i in 1:length(lambdavec)){
sumunit<-(1/(lambda[[id]]$Lambda+lambdavec[i])) #This creates the summation term unit by unit with the lambda i value and all of the respective lambda js
sumvec<-as.vector(c(sumvec,sumunit)) #this makes a vector of the summation terms
}
summationterm<-sum(sumvec) #here we sum the terms of the vector to plug into the equation
output<-(a-1+sum(dat[[id]]$Choose))/(b+summationterm) #this is where we finish up the equation and plug in all of our respective parts
return(output)
}
bradleyterry<-function(a,b,id,lambda,dat){
browser()
subsetdata<-dat[dat$DocIDi %in% id,]#this subsets the dataset down to just the observations with the id that we are looking at
newlambda<-lambda[lambda$DocId %in% id,]#this extracts the specific DocID and lambda value we want to upgrade for the purpose of the equation
sumvec<-NULL #create null vectors to store our sum elements
lambdavec<-NULL #create null vector to extract the lambda elements we want
for(i in 1:nrow(subsetdata)){ #the purpose of thsi loop is to extract lambda j values for use in the next loop
lambdajsubset<-lambda[lambda$DocId %in% subsetdata$DocIDj[i],] #This picks out the lambda j values for each of the elements of the subset dataset
lambdavec<-c(lambdavec,lambdajsubset$Lambda) #this building the vector for use
}
for (i in 1:nrow(subsetdata)){
sumunit<-(1/(newlambda$Lambda+lambdavec[i])) #This creates the summation term unit by unit with the lambda i value and all of the respective lambda js
sumvec<-as.vector(c(sumvec,sumunit)) #this makes a vector of the summation terms
}
summationterm<-sum(sumvec) #here we sum the terms of the vector to plug into the equation
output<-(a-1+sum(subsetdata$Choose))/(b+summationterm) #this is where we finish up the equation and plug in all of our respective parts
return(output)
}
bradleyterry(a=1,b=1,id=4969,lambda,HIT2)
bradleyterry.multid<-function(a, b, id, lambda, dat){
output<-sapply(id, function(x) bradleyterry(a,b,id=x, lambda, dat))
output<-cbind(id,output)
output<-as.data.frame(output)
colnames(output)<-c('DocId','Lambda')
return(output)
}
bradleyterry.multide<-function(a, b, id, lambda, dat){
output<-sapply(id, function(x) bradleyterryeasy(a,b,id=x, lambda, dat))
output<-cbind(id,output)
output<-as.data.frame(output)
colnames(output)<-c('DocId','Lambda')
newout<-lambdatrans(id,output)
return(output)
}
iterative.bt<-function(a,b,id,lambda,dat, iterations){
for (i in 1:iterations){   # from 1 to number of iteration, the loop repeats below function
lambda<-bradleyterry.multid(a,b,id,lambda,dat) #run the code above for one doc id, a number of times determined by user
}
return(lambda) #returns the output as the number of iterations determined by the user.
}
iterative.bt.tol<-function(a,b,id,lambda,dat,iterations){
for (i in 1:iterations){   # from 1 to number of iteration, the loop repeats below function
lambda1<-bradleyterry.multid(a,b,id,lambda,dat) #run the code above for one doc id, a number of times determined by user
if (all(abs(lambda1$Lambda-lambda$Lambda)<1e-2)){
break}
else{
lambda<-lambda1
}
}
return(lambda1) #returns the output as the number of iterations determined by the user.
}
recovered<-iterative.bt.tol(1,1,DocId,lambda,HIT2,1000)
bradleyterry.multid<-function(a, b, id, lambda, dat){
output<-sapply(id, function(x) bradleyterry(a,b,id=x, lambda, dat))
output<-cbind(id,output)
output<-as.data.frame(output)
colnames(output)<-c('DocId','Lambda')
return(output)
}
bradleyterry.multide<-function(a, b, id, lambda, dat){
output<-sapply(id, function(x) bradleyterryeasy(a,b,id=x, lambda, dat))
output<-cbind(id,output)
output<-as.data.frame(output)
colnames(output)<-c('DocId','Lambda')
newout<-lambdatrans(id,output)
return(output)
}
recovered<-iterative.bt.tol(1,1,DocId,lambda,HIT2,1000)
recovered<-recovered0
cor(recovered$Lambda,apiTest$rating)
library(readr)
apiTest <- read_csv("~/Documents/GitHub/BradelyTerryModel/apiTest.csv")
apiTest$id
apiTest$rating
install.packages("rstan")
library(rstan)
setwd("/Users/benjaminschneider/Documents/GitHub/BradelyTerryModel/")
load("fitExperiment2.7")
post.lambda = summary(fitExperiment2.7)$summary[paste0('a[',1:50,']'),'mean']
comparison<-cbind(apiTest$id,post.lambda)
comparison<-as.data.frame(comparison)
colnames(comparison)<-c("DocId", "Lambda")
recovered<-iterative.bt.tol(1,1,DocId,lambda,HIT2,1000)
dat<-read.csv("/Users/benjaminschneider/Documents/GitHub/BradelyTerryModel/CombinedOutputExperiment2.csv", header = T)
datatransform<-function(HIT){
vec<-rep(1:2, 1500)
HIT<-as.data.frame(cbind(HIT,vec))
colnames(HIT)<-c("comparison_id" ,"document_id", "result","num")
DocIDi<-NULL
DocIDj<-NULL
Choose<-NULL
for (i in 1:nrow(HIT)){ #create a vector of DocIDj composed of every other document_id, the document to which the document of interest of compared
if (HIT$num[i]==2){
DocIDj<-c(DocIDj,HIT$document_id[i])
}
else{
DocIDi<-c(DocIDi,HIT$document_id[i]) #create a vector of DocIDi composed every other document id, the document of interest
Choose<-c(Choose,HIT$result[i]) #1 indicates that the document of interest won; 0 indicates that the document of interest lost
}
}
newHIT<-as.data.frame(cbind(DocIDi,DocIDj,Choose))
DocIDi<-NULL #repeat the same process, but reverse the order of comparison; this ultimately allows us to update all lambdas
DocIDj<-NULL
Choose<-NULL
for (i in 1:nrow(HIT)){
if (HIT$num[i]==1){
DocIDj<-c(DocIDj,HIT$document_id[i])
}
else{
DocIDi<-c(DocIDi,HIT$document_id[i])
Choose<-c(Choose,HIT$result[i])
}
}
newHIT2<-as.data.frame(cbind(DocIDi,DocIDj,Choose))
metaHIT<-rbind(newHIT,newHIT2)
return(metaHIT)
}
HIT2<-datatransform(HIT)
DocId<-sort(unique(HIT$document_id), decreasing=F)
lambda<- as.data.frame(cbind(DocId, runif(50)))
colnames(lambda)<-c("DocIDj", "Lambda")
recovered<-iterative.bt(1,1,DocId,lambda,HIT2,1000)
iterative.bt(1,1,DocId,lambda,HIT2,1000)
