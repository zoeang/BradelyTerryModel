<<<<<<< HEAD
bradleyterry.easy<-function(a,b,id,lambda,dataset){
sumvec<-NULL #create null vectors to store our sum elements
lambdavec<-NULL #create null vector to extract the lambda elements we want
for(i in 1:nrow(dataset[[id]])){ #the purpose of thsi loop is to extract lambda j values for use in the next loop
lambdajsubset<-dataset[[id]]$DocIDj[i] #This picks out the lambda j values for each of the elements of the subset dataset
lambdaj<-lambda[[lambdajsubset]]$Lambda
lambdavec<-c(lambdavec,lambdaj) #this building the vector for use
}
for (i in 1:length(lambdavec)){
sumunit<-(1/(lambda[[id]]$Lambda+lambdavec[i])) #This creates the summation term unit by unit with the lambda i value and all of the respective lambda js
sumvec<-as.vector(c(sumvec,sumunit)) #this makes a vector of the summation terms
}
summationterm<-sum(sumvec) #here we sum the terms of the vector to plug into the equation
output<-(a-1+sum(dataset[[id]]$Choose))/(b+summationterm) #this is where we finish up the equation and plug in all of our respective parts
return(output)
}
bradleyterry<-function(a,b,id,lambda,dataset){
subsetdata<-dataset[dataset$DocIDi %in% id,]#this subsets the dataset down to just the observations with the id that we are looking at
newlambda<-lambda[lambda$DocId %in% id,]#this extracts the specific DocID and lambda value we want to upgrade for the purpose of the equation
sumvec<-NULL #create null vectors to store our sum elements
lambdavec<-NULL #create null vector to extract the lambda elements we want
for(i in 1:nrow(subsetdata)){ #the purpose of thsi loop is to extract lambda j values for use in the next loop
lambdajsubset<-lambda[lambda$DocId %in% subsetdata$DocIDj[i],] #This picks out the lambda j values for each of the elements of the subset dataset
lambdavec<-c(lambdavec,lambdajsubset$Lambda) #this building the vector for use
}
for (i in 1:nrow(subsetdata)){
sumunit<-(1/(newlambda$Lambda+lambdavec[i])) #This creates the summation term unit by unit with the lambda i value and all of the respective lambda js
sumvec<-as.vector(c(sumvec,sumunit)) #this makes a vector of the summation terms
}
summationterm<-sum(sumvec) #here we sum the terms of the vector to plug into the equation
output<-(a-1+sum(subsetdata$Choose))/(b+summationterm) #this is where we finish up the equation and plug in all of our respective parts
return(output)
}
bradleyterry.easy(1,1,4990,test2,test1)
bradleyterry(1,1,4990,HIT2,lambda)
lambda
HIT2
dataset<-HIT2
id<-4990
subsetdata<-dataset[dataset$DocIDi %in% id,]#this subsets the dataset down to just the observations with the id that we are looking at
newlambda<-lambda[lambda$DocId %in% id,]#this extracts the specific DocID and lambda value we want to upgrade for the purpose of the equation
sumvec<-NULL #create null vectors to store our sum elements
lambdavec<-NULL #create null vector to extract the lambda elements we want
for(i in 1:nrow(subsetdata)){ #the purpose of thsi loop is to extract lambda j values for use in the next loop
lambdajsubset<-lambda[lambda$DocId %in% subsetdata$DocIDj[i],] #This picks out the lambda j values for each of the elements of the subset dataset
lambdavec<-c(lambdavec,lambdajsubset$Lambda) #this building the vector for use
}
for (i in 1:nrow(subsetdata)){
sumunit<-(1/(newlambda$Lambda+lambdavec[i])) #This creates the summation term unit by unit with the lambda i value and all of the respective lambda js
sumvec<-as.vector(c(sumvec,sumunit)) #this makes a vector of the summation terms
}
summationterm<-sum(sumvec) #here we sum the terms of the vector to plug into the equation
output<-(a-1+sum(subsetdata$Choose))/(b+summationterm) #this is where we finish up the equation and plug in all of our respective parts
a=1
b=1
output<-(a-1+sum(subsetdata$Choose))/(b+summationterm) #this is where we finish up the equation and plug in all of our respective parts
return(output)
output
bradleyterry<-function(a,b,id,lambda,dataset){
subsetdata<-dataset[dataset$DocIDi %in% id,]#this subsets the dataset down to just the observations with the id that we are looking at
newlambda<-lambda[lambda$DocId %in% id,]#this extracts the specific DocID and lambda value we want to upgrade for the purpose of the equation
sumvec<-NULL #create null vectors to store our sum elements
lambdavec<-NULL #create null vector to extract the lambda elements we want
for(i in 1:nrow(subsetdata)){ #the purpose of thsi loop is to extract lambda j values for use in the next loop
lambdajsubset<-lambda[lambda$DocId %in% subsetdata$DocIDj[i],] #This picks out the lambda j values for each of the elements of the subset dataset
lambdavec<-c(lambdavec,lambdajsubset$Lambda) #this building the vector for use
}
for (i in 1:nrow(subsetdata)){
sumunit<-(1/(newlambda$Lambda+lambdavec[i])) #This creates the summation term unit by unit with the lambda i value and all of the respective lambda js
sumvec<-as.vector(c(sumvec,sumunit)) #this makes a vector of the summation terms
}
summationterm<-sum(sumvec) #here we sum the terms of the vector to plug into the equation
output<-(a-1+sum(subsetdata$Choose))/(b+summationterm) #this is where we finish up the equation and plug in all of our respective parts
return(output)
}
bradleyterry(1,1,4990,HIT2,lambda)
bradleyterry.easy(1,1,4990,test2,test1)
subsetdata<-dataset[dataset$DocIDi %in% id,]#this subsets the dataset down to just the observations with the id that we are looking at
newlambda<-lambda[lambda$DocId %in% id,]#this extracts the specific DocID and lambda value we want to upgrade for the purpose of the equation
sumvec<-NULL #create null vectors to store our sum elements
lambdavec<-NULL #create null vector to extract the lambda elements we want
for(i in 1:nrow(subsetdata)){ #the purpose of thsi loop is to extract lambda j values for use in the next loop
lambdajsubset<-lambda[lambda$DocId %in% subsetdata$DocIDj[i],] #This picks out the lambda j values for each of the elements of the subset dataset
lambdavec<-c(lambdavec,lambdajsubset$Lambda) #this building the vector for use
}
for (i in 1:nrow(subsetdata)){
sumunit<-(1/(newlambda$Lambda+lambdavec[i])) #This creates the summation term unit by unit with the lambda i value and all of the respective lambda js
sumvec<-as.vector(c(sumvec,sumunit)) #this makes a vector of the summation terms
}
summationterm<-sum(sumvec) #here we sum the terms of the vector to plug into the equation
output<-(a-1+sum(subsetdata$Choose))/(b+summationterm) #this is where we finish up the equation and plug in all of our respective parts
output
bradleyterry<-function(a,b,id,lambda,dataset){
subsetdata<-dataset[dataset$DocIDi %in% id,]#this subsets the dataset down to just the observations with the id that we are looking at
newlambda<-lambda[lambda$DocId %in% id,]#this extracts the specific DocID and lambda value we want to upgrade for the purpose of the equation
sumvec<-NULL #create null vectors to store our sum elements
lambdavec<-NULL #create null vector to extract the lambda elements we want
for(i in 1:nrow(subsetdata)){ #the purpose of thsi loop is to extract lambda j values for use in the next loop
lambdajsubset<-lambda[lambda$DocId %in% subsetdata$DocIDj[i],] #This picks out the lambda j values for each of the elements of the subset dataset
lambdavec<-c(lambdavec,lambdajsubset$Lambda) #this building the vector for use
}
for (i in 1:nrow(subsetdata)){
sumunit<-(1/(newlambda$Lambda+lambdavec[i])) #This creates the summation term unit by unit with the lambda i value and all of the respective lambda js
sumvec<-as.vector(c(sumvec,sumunit)) #this makes a vector of the summation terms
}
summationterm<-sum(sumvec) #here we sum the terms of the vector to plug into the equation
output<-(a-1+sum(subsetdata$Choose))/(b+summationterm) #this is where we finish up the equation and plug in all of our respective parts
return(output)
}
bradleyterry(1,1,4990,HIT2,lambda)
HIT2
lambda
bradleyterry.easy(1,1,4990,test2,test1)
bradleyterry(1,1,4990,lambda,HIT2)
bradleyterry.easy(1,1,5015,test2,test1)
bradleyterry(1,1,5015,lambda,HIT2)
bradleyterry.easy<-function(a,b,id,lambda,dataset){
sumvec<-NULL #create null vectors to store our sum elements
lambdavec<-NULL #create null vector to extract the lambda elements we want
for(i in 1:nrow(dataset[[id]])){ #the purpose of thsi loop is to extract lambda j values for use in the next loop
lambdajsubset<-dataset[[id]]$DocIDj[i] #This picks out the lambda j values for each of the elements of the subset dataset
lambdaj<-lambda[[lambdajsubset]]$Lambda
lambdavec<-c(lambdavec,lambdaj) #this building the vector for use
}
for (i in 1:length(lambdavec)){
sumunit<-(1/(lambda[[id]]$Lambda+lambdavec[i])) #This creates the summation term unit by unit with the lambda i value and all of the respective lambda js
sumvec<-as.vector(c(sumvec,sumunit)) #this makes a vector of the summation terms
}
summationterm<-sum(sumvec) #here we sum the terms of the vector to plug into the equation
output<-(a-1+sum(dataset[[id]]$Choose))/(b+summationterm) #this is where we finish up the equation and plug in all of our respective parts
return(output)
}
bradleyterry<-function(a,b,id,lambda,dataset){
subsetdata<-dataset[dataset$DocIDi %in% id,]#this subsets the dataset down to just the observations with the id that we are looking at
newlambda<-lambda[lambda$DocId %in% id,]#this extracts the specific DocID and lambda value we want to upgrade for the purpose of the equation
sumvec<-NULL #create null vectors to store our sum elements
lambdavec<-NULL #create null vector to extract the lambda elements we want
for(i in 1:nrow(subsetdata)){ #the purpose of thsi loop is to extract lambda j values for use in the next loop
lambdajsubset<-lambda[lambda$DocId %in% subsetdata$DocIDj[i],] #This picks out the lambda j values for each of the elements of the subset dataset
lambdavec<-c(lambdavec,lambdajsubset$Lambda) #this building the vector for use
}
for (i in 1:nrow(subsetdata)){
sumunit<-(1/(newlambda$Lambda+lambdavec[i])) #This creates the summation term unit by unit with the lambda i value and all of the respective lambda js
sumvec<-as.vector(c(sumvec,sumunit)) #this makes a vector of the summation terms
}
summationterm<-sum(sumvec) #here we sum the terms of the vector to plug into the equation
output<-(a-1+sum(subsetdata$Choose))/(b+summationterm) #this is where we finish up the equation and plug in all of our respective parts
return(output)
}
microbenchmark(bradleyterry.easy(1,1,5015,test2,test1))
library(microbenchmark)
microbenchmark(bradleyterry.easy(1,1,5015,test2,test1))
microbenchmark(bradleyterry(1,1,5015,lambda,HIT2))
microbenchmark(bradleyterry.easy(1,1,5015,test2,test1),times=1000)
microbenchmark(bradleyterry(1,1,5015,lambda,HIT2)times=1000)
microbenchmark(bradleyterry(1,1,5015,lambda,HIT2),times=1000)
bradleyterry.multid<-function(a, b, id, lambda, dataset){
output<-sapply(id, function(x) bradleyterry(a,b,id=x, lambda, dataset))
output<-cbind(id,output)
output<-as.data.frame(output)
colnames(output)<-c('DocId','Lambda')
return(output)
}
bradleyterry.multide<-function(a, b, id, lambda, dataset){
output<-sapply(id, function(x) bradleyterry.easy(a,b,id=x, lambda, dataset))
output<-cbind(id,output)
output<-as.data.frame(output)
colnames(output)<-c('DocId','Lambda')
return(output)
}
bradleyterry.multid<-function(a, b, id, lambda, dataset){
output<-sapply(id, function(x) bradleyterry(a,b,id=x, lambda, dataset))
output<-cbind(id,output)
output<-as.data.frame(output)
colnames(output)<-c('DocId','Lambda')
return(output)
}
bradleyterry.multide<-function(a, b, id, lambda, dataset){
output<-sapply(id, function(x) bradleyterry.easy(a,b,id=x, lambda, dataset))
output<-cbind(id,output)
output<-as.data.frame(output)
colnames(output)<-c('DocId','Lambda')
return(output)
}
microbenchmark(bradleyterry.multid(1,1,DocId, lambda, HIT2),times=1000)
bradleyterry.multid(1,1,DocId, lambda, HIT2)
bradleyterry.multide(1,1,DocId, test2, test1)
microbenchmark(bradleyterry.multid(1,1,DocId, lambda, HIT2),times=100)
microbenchmark(bradleyterry.multide(1,1,DocId, test2, test1), times=100)
a<-bradleyterry.multid(1,1,DocId, lambda, HIT2)
b<-bradleyterry.multide(1,1,DocId, test2, test1)
cor(a$Lambda,b$Lambda)
plot(a$Lambda,b$Lambda)
bradleyterryeasy<-function(a,b,id,lambda,dataset){
sumvec<-NULL #create null vectors to store our sum elements
lambdavec<-NULL #create null vector to extract the lambda elements we want
for(i in 1:nrow(dataset[[id]])){ #the purpose of thsi loop is to extract lambda j values for use in the next loop
lambdajsubset<-dataset[[id]]$DocIDj[i] #This picks out the lambda j values for each of the elements of the subset dataset
lambdaj<-lambda[[lambdajsubset]]$Lambda
lambdavec<-c(lambdavec,lambdaj) #this building the vector for use
}
for (i in 1:length(lambdavec)){
sumunit<-(1/(lambda[[id]]$Lambda+lambdavec[i])) #This creates the summation term unit by unit with the lambda i value and all of the respective lambda js
sumvec<-as.vector(c(sumvec,sumunit)) #this makes a vector of the summation terms
}
summationterm<-sum(sumvec) #here we sum the terms of the vector to plug into the equation
output<-(a-1+sum(dataset[[id]]$Choose))/(b+summationterm) #this is where we finish up the equation and plug in all of our respective parts
return(output)
}
bradleyterry.multide<-function(a, b, id, lambda, dataset){
output<-sapply(id, function(x) bradleyterryeasy(a,b,id=x, lambda, dataset))
output<-cbind(id,output)
output<-as.data.frame(output)
colnames(output)<-c('DocId','Lambda')
return(output)
}
iterative.bte<-function(a,b,id,lambda,dataset, iterations){
for (i in 1:iterations){   # from 1 to number of iteration, the loop repeats below function
lambda<-bradleyterry.multide(a,b,id,lambda,dataset) #run the code above for one doc id, a number of times determined by user
}
return(lambda) #returns the output as the number of iterations determined by the user.
}
microbenchmark(iterative.bt(1,1,DocId,lambda,HIT2, 50),times=5)
microbenchmark(iterative.bte(1,1,DocId,test2,test1, 50),times=5)
iterative.bte<-function(a,b,id,lambda,dataset, iterations){
for (i in 1:iterations){   # from 1 to number of iteration, the loop repeats below function
lambda<-bradleyterry.multide(a,b,id,lambda,dataset) #run the code above for one doc id, a number of times determined by user
}
return(lambda) #returns the output as the number of iterations determined by the user.
}
microbenchmark(iterative.bte(1,1,DocId,test2,test1, 50),times=5)
iterative.bte(1,1,DocId,test2,test1, 50)
bradleyterry.multide<-function(a, b, id, lambda, dataset){
output<-sapply(id, function(x) bradleyterryeasy(a,b,id=x, lambda, dataset))
output<-cbind(id,output)
output<-as.data.frame(output)
colnames(output)<-c('DocId','Lambda')
return(output)
}
bradleyterryeasy<-function(a,b,id,lambda,dataset){
sumvec<-NULL #create null vectors to store our sum elements
lambdavec<-NULL #create null vector to extract the lambda elements we want
for(i in 1:nrow(dataset[[id]])){ #the purpose of thsi loop is to extract lambda j values for use in the next loop
lambdajsubset<-dataset[[id]]$DocIDj[i] #This picks out the lambda j values for each of the elements of the subset dataset
lambdaj<-lambda[[lambdajsubset]]$Lambda
lambdavec<-c(lambdavec,lambdaj) #this building the vector for use
}
for (i in 1:length(lambdavec)){
sumunit<-(1/(lambda[[id]]$Lambda+lambdavec[i])) #This creates the summation term unit by unit with the lambda i value and all of the respective lambda js
sumvec<-as.vector(c(sumvec,sumunit)) #this makes a vector of the summation terms
}
summationterm<-sum(sumvec) #here we sum the terms of the vector to plug into the equation
output<-(a-1+sum(dataset[[id]]$Choose))/(b+summationterm) #this is where we finish up the equation and plug in all of our respective parts
return(output)
}
bradleyterry.multide<-function(a, b, id, lambda, dataset){
output<-sapply(id, function(x) bradleyterryeasy(a,b,id=x, lambda, dataset))
output<-cbind(id,output)
output<-as.data.frame(output)
colnames(output)<-c('DocId','Lambda')
return(output)
}
iterative.bte<-function(a,b,id,lambda,dataset, iterations){
for (i in 1:iterations){   # from 1 to number of iteration, the loop repeats below function
lambda<-bradleyterry.multide(a,b,id,lambda,dataset) #run the code above for one doc id, a number of times determined by user
}
return(lambda) #returns the output as the number of iterations determined by the user.
}
iterative.bte(1,1,DocId,test2,test1, 50)
iterative.bte(1,1,DocId,test2,test1,5)
iterative.bt(1,1,DocId,lambda,HIT2, 50)
iterative.bte(1,1,DocId,lambda,HIT2, 50)
iterative.bte<-function(a,b,id,lambda,dataset, iterations){
for (i in 1:iterations){   # from 1 to number of iteration, the loop repeats below function
lambda<-bradleyterry.multide(a,b,id,lambda,dataset) #run the code above for one doc id, a number of times determined by user
lambda<-lambdatrans(id,lambda)
}
return(lambda) #returns the output as the number of iterations determined by the user.
}
iterative.bte(1,1,DocId,lambda,HIT2, 50)
bradleyterry.multide(1,1,DocId,test2,test1)
lambda<-bradleyterry.multide(1,1,DocId,test2,test1)
lambda<-lambdatrans(DocId,lambda)
lambda
for (i in 1:5){   # from 1 to number of iteration, the loop repeats below function
lambda<-bradleyterry.multide(a,b,id,lambda,dataset) #run the code above for one doc id, a number of times determined by user
lambda<-lambdatrans(id,lambda)
}
for (i in 1:5){   # from 1 to number of iteration, the loop repeats below function
lambda<-bradleyterry.multide(a,b,id,lambda,dataset) #run the code above for one doc id, a number of times determined by user
lambda<-lambdatrans(id,lambda)
}
bradleyterry.multide<-function(a, b, id, lambda, dataset){
output<-sapply(id, function(x) bradleyterryeasy(a,b,id=x, lambda, dataset))
return(output)
}
bradleyterry.multide(1,1,DocId,test2,test1)
bradleyterry.multide<-function(a, b, id, lambda, dataset){
output<-sapply(id, function(x) bradleyterryeasy(a,b,id=x, lambda, dataset))
return(output)
}
bradleyterry.multide(1,1,DocId,test2,test1)
bradleyterry.multide<-function(a, b, id, lambda, dataset){
output<-sapply(id, function(x) bradleyterryeasy(a,b,id=x, lambda, dataset))
output<-cbind(id,output)
output<-as.data.frame(output)
colnames(output)<-c('DocId','Lambda')
return(output)
}
lambda<-bradleyterry.multide(1,1,DocId,test2,test1)
lambda<-lambdatrans(DocId,lambda)
bradleyterry.multide(1,1,DocId,test2,test1)
for (i in 1:2){   # from 1 to number of iteration, the loop repeats below function
lambda<-bradleyterry.multide(a,b,id,lambda,dataset) #run the code above for one doc id, a number of times determined by user
lambda<-lambdatrans(id,lambda)
}
bradleyterry.multide<-function(a, b, id, lambda, dataset){
output<-sapply(id, function(x) bradleyterryeasy(a,b,id=x, lambda, dataset))
output<-cbind(id,output)
output<-as.data.frame(output)
colnames(output)<-c('DocId','Lambda')
newout<-lambdatrans(id,output)
return(output)
}
iterative.bt<-function(a,b,id,lambda,dataset, iterations){
for (i in 1:iterations){   # from 1 to number of iteration, the loop repeats below function
lambda<-bradleyterry.multide(a,b,id,lambda,dataset) #run the code above for one doc id, a number of times determined by user
}
return(lambda) #returns the output as the number of iterations determined by the user.
}
iterative.bte<-function(a,b,id,lambda,dataset, iterations){
for (i in 1:iterations){   # from 1 to number of iteration, the loop repeats below function
lambda<-bradleyterry.multide(a,b,id,lambda,dataset) #run the code above for one doc id, a number of times determined by user
}
return(lambda) #returns the output as the number of iterations determined by the user.
}
iterative.bt<-function(a,b,id,lambda,dataset, iterations){
for (i in 1:iterations){   # from 1 to number of iteration, the loop repeats below function
lambda<-bradleyterry.multid(a,b,id,lambda,dataset) #run the code above for one doc id, a number of times determined by user
}
return(lambda) #returns the output as the number of iterations determined by the user.
}
iterative.bte(1,1,DocId,test2,test1,3)
garrettmod<-lm(gdp~leftlab+corp+capmob+infl, garrett1998)
library(readr)
garrett1998 <- read_delim("~/Desktop/QPM 1 Rosas/garrett1998.tab", "\t", escape_double = FALSE, trim_ws = TRUE)
garrettmod<-lm(gdp~leftlab+corp+capmob+infl, garrett1998)
stargazer(garrettmod)
library(stargazerx)
library(stargazer)
stargazer(garrettmod)
lmrob(gdp~leftlab+corp+capmob+infl, garrett1998)
library(sandwich)
congress
data(congress
data(congress)
library(datasets)
congress
data(congress)
library(car)
data(congress)
congress
attach(congress)
library(AER)
library(arm)
attach(congress)
data(congress)
congress
library(arm)
data(congress)
congress
library(readr)
March2018_CSV <- read_csv("~/Documents/GitHub/PS7/March2018.CSV.html")
View(March2018_CSV)
library(dplyr)
library(ggplot)
library(ggplot2)
?filter
March2018 <- read_csv("~/Documents/GitHub/PS7/March2018.CSV.html")
march2018 <- read_csv("~/Documents/GitHub/PS7/March2018.CSV.html")
summary(march2018$Description)
filter(march2018, description == "homicide")
read.table("/Users/benjaminschneider/Downloads/congress.txt",header=T)
congress<-read.table("/Users/benjaminschneider/Downloads/congress.txt",header=T)
View(congress)
newcongress<-subset(congress, CONTST94!=0)
newcongress
model<-lm(DVOTE94~DVOTE92+DWIN92,newcongress)
stargazer(model)
plot(residuals(model))
lm(DVOTE94~DVOTE92+DWIN92+factor(STATE),newcongress)
summary(lm(DVOTE94~DVOTE92+DWIN92+factor(STATE),newcongress))
fixedmod<-lm(DVOTE94~DVOTE92+DWIN92+factor(STATE),newcongress)
stargazer(model,fixedmod)
n <- nrow(model.matrix(garrettmod)) #number of rows (observations)
k <- ncol(model.matrix(garrettmod))
se.r <- as.matrix(coeftest(garrettmod, n/(n-k)*sandwich(garrettmod)))[,2] #robust standard errors
library(sandwich)
se.r <- as.matrix(coeftest(garrettmod, n/(n-k)*sandwich(garrettmod)))[,2] #robust standard errors
library(sandwich)
library(lmtest)
n <- nrow(model.matrix(garrettmod)) #number of rows (observations)
k <- ncol(model.matrix(garrettmod))
se.r <- as.matrix(coeftest(garrettmod, n/(n-k)*sandwich(garrettmod)))[,2] #robust standard errors
car::ncvTest(garrettmod) #not heteroskedasticity
plot(garrettmod$residuals, garrettmod$fitted.values) # no correlation between residuals
se.r
cbind(garrettmod$residuals,se.r)
se.r
stargazer(garrettmod,garretmod)
stargazer(garrettmod,garreTtmod)
stargazer(garrettmod,garrettmod)
se.r
car::ncvTest(garrettmod) #not heteroskedasticity
plot(garrettmod$residuals, garrettmod$fitted.values, main="Check of Residuals vs Fitted Values") # no correlation between residuals
library(pcse)
library(pcse)
dat<-cbind(1:25,runif(25))
set.seed(5)
dat<-cbind(1:25,runif(25))
dat<-as.data.frame(dat)
colnames(dat)<-c("Y","X")
lm(Y~X,dat)
plot(dat$X,dat$Y)
abline(-1.513,13.742)
plot(dat$Y,dat$X)
abline(-1.513,13.742)
set.seed(5)
dat<-cbind(1:25,runif(25))
dat<-as.data.frame(dat)
colnames(dat)<-c("X","Y")
lm(Y~X,dat)
plot(dat$Y,dat$X)
plot(dat$X,dat$Y)
abline(-0.002328,0.520727)
abline(0.520727,-0.002328)
plot(dat$X,dat$Y)
abline(0.520727,-0.002328)
set.seed(5)
dat<-cbind(1:100,runif(100))
dat<-as.data.frame(dat)
colnames(dat)<-c("X","Y")
lm(Y~X,dat)
plot(dat$X,dat$Y)
dat<-cbind(1:50,2:51)
dat<-as.data.frame(dat)
colnames(dat)<-c("X","Y")
lm(Y~X,dat)
plot(dat$X,dat$Y)
abline(1,1,col="red")
summary(march2018$Description)
filter(march2018, description %>% "homicide")
filter(march2018, Description %>% "homicide")
dat<-cbind(1:50,2:51)
x<-1:50
treatment<-sample(c(0,1), 50, replace = TRUE, prob = c(.5,.5))
for (i in length(x)){
if (treatment==1){
y<-x*2
}
else {
y<-x
}
}
y
for (i in length(x)){
if (treatment[i]==1){
y<-x+2
}
else {
`y<-x
}
}
y
for (i in length(x)){
if (treatment[i]==1){
y<-x+2
}
else {
y<-x
}
}
y
for (i in length(x)){
if (treatment[i]==1){
y<-x+2
}
else {
y<-x
}
}
for (i in 1:length(x)){
if (treatment[i]==1){
y<-x+2
}
else {
y<-x
}
}
y
for (i in 1:length(x)){
if (treatment[i]==1){
y<-x+2}
else {
y<-x}
}
y
dat<-as.data.frame(dat)
colnames(dat)<-c("X","Y")
lm(Y~X,dat)
plot(dat$X,dat$Y)
abline(1,1,col="red")
=======
n      = rep(1:100,2)
a      = 0
b      = 1
sigma2 = n^2
eps    = rnorm(n,mean=0,sd=sqrt(sigma2))
y      = a+b*n + eps
mod    = lm(y ~ n)
res    = residuals(mod)
plot(n,y)
abline(coef(mod), col="red")
n      = rep(1:100,2)
a      = 0
b      = 1
sigma2 = n^1.5
eps    = rnorm(n,mean=0,sd=sqrt(sigma2))
y      = a+b*n + eps
mod    = lm(y ~ n)
res    = residuals(mod)
plot(n,y)
abline(coef(mod), col="red")
n
x      = rep(1:100,2)
a      = 0
b      = 1
sigma2 = n^1.5
eps    = rnorm(n,mean=0,sd=sqrt(sigma2))
y      = a+b*x + eps
mod    = lm(y ~ x)
res    = residuals(mod)
plot(x,y)
abline(coef(mod), col="red")
x      = (1:100)
a      = 0
b      = 1
sigma2 = n^1.5
eps    = rnorm(n,mean=0,sd=sqrt(sigma2))
y      = a+b*x + eps
mod    = lm(y ~ x)
res    = residuals(mod)
x      = (1:100)
x
a      = 0
b      = 1
sigma2 = n^1.5
eps    = rnorm(n,mean=0,sd=sqrt(sigma2))
x      = (1:100)
a      = 0
b      = 1
sigma2 = x^1.5
eps    = rnorm(n,mean=0,sd=sqrt(sigma2))
y      = a+b*x + eps
mod    = lm(y ~ x)
res    = residuals(mod)
x      = (1:100)
a      = 0
b      = 1
sigma2 = x^1.5
eps    = rnorm(x,mean=0,sd=sqrt(sigma2))
y      = a+b*x + eps
mod    = lm(y ~ x)
res    = residuals(mod)
plot(x,y)
abline(coef(mod), col="red")
sample(100,x,replace = T)
sample(100,x,replace = T)
sample(x,size=100,replace = T)
resamples <- lapply(1:500, function(i) sample(x, replace = T))
resamples
lm(resamples_y~resamples_x)
resamples_x <- lapply(1:500, function(i) sample(x, replace = T))
resamples_y <- lapply(1:500, function(i) sample(x, replace = T))
lm(resamples_y~resamples_x)
lm(resamples_y[1]~resamples_x[1])
lm(resamples_y[[1]]~resamples_x[[1]])
lm(resamples_y[[i]]~resamples_x[[i]])[2]
lm(resamples_y[[1]]~resamples_x[[1]])[2]
lm(resamples_y[[1]]~resamples_x[[1]])$coefficient
lm(resamples_y[[1]]~resamples_x[[1]])$coefficient[1]
lm(resamples_y[[1]]~resamples_x[[1]])$coefficient[2]
for (i in 1:500){
dat<-NULL
dat<-lm(resamples_y[[i]]~resamples_x[[i]])$coefficient[2]
}
dat
dat<-as.data.frame(matrix(, nrow=500))
dat
dat<-as.data.frame(matrix(, nrow=500))
for (i in 1:500){
dat[i]<-lm(resamples_y[[i]]~resamples_x[[i]])$coefficient[2]
}
dat
dat<-as.data.frame(matrix(, nrow=500))
for (i in 1:500){
dat[i,1]<-lm(resamples_y[[i]]~resamples_x[[i]])$coefficient[2]
}
dat
mod
mod$coefficients[2]
mean(dat$V1)
actual
actual<-mod$coefficients[2]
actual
mean_boot<-mean(dat$V1)
mean_boot
cbind(x,y)
x<-as.data.frame(x)
y<-as.data.frame(y)
x
comb<-cbind(x,y)
actual
pred.y<-predict(comb, newdata = validation[,-1],interval='prediction',level=0.95)
x<-as.matrix(x)
y<-as.matrix(y)
comb<-cbind(x,y)
pred.y<-predict(comb, newdata = validation[,-1],interval='prediction',level=0.95)
class(x)
x      = (1:100)
y      = a+b*x + eps
x<-as.matrix(x)
y<-as.matrix(y)
comb<-cbind(x,y)
actual
class(x)
pred.y<-predict(comb, newdata = validation[,-1],interval='prediction',level=0.95)
class(x)
class(y)
comb<-cbind(x,y)
x      = (1:100)
y      = a+b*x + eps
x
y
comb<-cbind(x,y)
comb
pred.y<-predict(comb, newdata = validation[,-1],interval='prediction',level=0.95)
class(x)
pred.y<-coef(mod)[1] + 1*coef(mod)[2]
pred.y
pred.y<-coef(mod)[1] + 1*coef(mod)[2]
pred.y<-coef(mod)[1] + x*coef(mod)[2]
pred.y
eps
resamples_eps
resamples_eps <- lapply(1:500, function(i) sample(eps, replace = T))
resamples_eps
dat2<-as.data.frame(matrix(, nrow=500))
dat2
dat2<-as.data.frame(matrix(, nrow=500,ncol=2))
for (i in 1:500){
dat2[i,1]<-pred.y+resample[[i]]
dat2[i,2]<-lm(dat2$V1~x)$coefficient[2]
}
dat2
dat2<-as.data.frame(matrix(, nrow=500,ncol=2))
for (i in 1:500){
dat2[i,1]<-pred.y+resamples_eps[[i]]
dat2[i,2]<-lm(dat2$V1~x)$coefficient[2]
}
dat2<-as.data.frame(matrix(, nrow=500,ncol=1))
for (i in 1:500){
ys<-pred.y+resamples_eps[[i]]
dat2[i,1]<-lm(dat2$V1~x)$coefficient[2]
}
dat2<-as.data.frame(matrix(, nrow=500,ncol=1))
for (i in 1:500){
ys<-pred.y+resamples_eps[[i]]
dat2[i,1]<-lm(ys~x)$coefficient[2]
}
dat2
mean_boot<-mean(dat2$V1)
actual<-mod$coefficients[2]
mean_boot
actual
install.packages("RcppArmadillo")
library("RcppArmadillo")
library(dplyr)
install.packages("nycflights13")
data(flights)
library(nycflights13)
data(flights)
head(flights)
justMay<-filter(flights, month==5)
head(justMay)
class(justMay)
arrange(flights, day)
arrange(flights, desc(day))
select(flights, year)
select(flights, year:day)
summarise(flights, delay=mean(dep_delay, na.rm=TRUE))
by_day <- group_by(flights, year, month, day)
summarise(by_day, delay=mean(dep_delay, na.rm=TRUE))
by_day
summarise(by_day, delay=mean(dep_delay, na.rm=TRUE))
n(1)
n(by_day)
require(devtools)
install_github("mattblackwell/DirectEffects", ref = "master")
datatransform<-function(HIT){
vec<-rep(1:2, 1500)
HIT<-cbind(HIT,vec)
HIT<-as.data.frame((HIT))
colnames(HIT)<-c("comparison_id" ,"document_id", "result","num")
DocIDi<-NULL
DocIDj<-NULL
Choose<-NULL
for (i in 1:nrow(HIT)){
if (HIT$num[i]==2){
DocIDj<-c(DocIDj,HIT$document_id[i])
}
else{
DocIDi<-c(DocIDi,HIT$document_id[i])
Choose<-c(Choose,HIT$result[i])
}
}
newHIT<-as.data.frame(cbind(DocIDi,DocIDj,Choose))
DocIDi<-NULL
DocIDj<-NULL
Choose<-NULL
for (i in 1:nrow(HIT)){
if (HIT$num[i]==1){
DocIDj<-c(DocIDj,HIT$document_id[i])
}
else{
DocIDi<-c(DocIDi,HIT$document_id[i])
Choose<-c(Choose,HIT$result[i])
}
}
newHIT2<-as.data.frame(cbind(DocIDi,DocIDj,Choose))
metaHIT<-rbind(newHIT,newHIT2)
return(metaHIT)
}
HIT2<-datatransform(HIT)
HIT<-read.csv("C:/Users/dell/Documents/GitHub/BradelyTerryModel/exampleHITs.csv", header=T)
HIT
HIT2<-datatransform(HIT)
datat<-function(docid,dataset){
list1<-list()
for (i in docid){
subset<-dataset[dataset$DocIDi %in% i,]
list1<-subset
}
}
DocId
HIT2
DocId<-c(5092,5099)
datatrans(DocId,HIT2)
DocId<-c(5092,5099)
datat(DocId,HIT2)
A<-datat(DocId,HIT2)
A
datat<-function(docid,dataset){
list1<-list()
for (i in docid){
subset<-dataset[dataset$DocIDi %in% i,]
list1<-subset
}
}
A<-datat(DocId,HIT2)
A
datat<-function(docid,dataset){
list<-list()
list1<-list()
for (i in docid){
list1<-dataset[dataset$DocIDi %in% i,]
list<-c(list,list1)
}
}
A<-datat(DocId,HIT2)
A
for (i in DocId){
list1<-dataset[dataset$DocIDi %in% i,]
list<-c(list,list1)
}
for (i in DocId){
list1<-HIT2[HIT2$DocIDi %in% i,]
list<-c(list,list1)
}
list
datat<-function(docid,HIT2){
list<-list()
list1<-list()
for (i in DocId){
list1<-HIT2[HIT2$DocIDi %in% i,]
list<-c(list,list1)
}
}
A<-datat(DocId,HIT2)
A
datat<-function(docid,HIT2){
list<-list(NULL)
list1<-list()
for (i in DocId){
list1<-HIT2[HIT2$DocIDi %in% i,]
list<-c(list,list1)
}
}
A<-datat(DocId,HIT2)
A
datat<-function(docid,HIT2){
list<-list()
for (i in DocId){
a<-HIT2[HIT2$DocIDi %in% i,]
list<-c(list,a)
}
}
A<-datat(DocId,HIT2)
A
for (i in DocId){
a<-HIT2[HIT2$DocIDi %in% i,]
list<-c(list,a)
}
list
list1<-list()
list1
datat<-function(docid,HIT2){
l<-NULL
list1<-list()
for (i in DocId){
a<-HIT2[HIT2$DocIDi %in% i,]
list1<-c(list1,a)
}
}
A<-datat(DocId,HIT2)
A
datat<-function(docid,HIT2){
l<-NULL
list1<-list(l)
for (i in DocId){
a<-HIT2[HIT2$DocIDi %in% i,]
list1<-c(list1,a)
}
}
A<-datat(DocId,HIT2)
A
datat<-function(docid,HIT2){
l<-NULL
list1<-as.list(l)
for (i in DocId){
a<-HIT2[HIT2$DocIDi %in% i,]
list1<-c(list1,a)
}
}
A<-datat(DocId,HIT2)
A
datat<-function(docid,d){
l<-NULL
list1<-as.list(l)
for (i in docid){
a<-HIT2[HIT2$DocIDi %in% i,]
list1<-c(list1,a)
}
}
A<-datat(DocId,HIT2)
A
datat<-function(docid,d){
l<-NULL
list1<-as.list(l)
for (i in docid){
a<-d[d$DocIDi %in% i,]
list1<-c(list1,a)
}
}
A<-datat(DocId,HIT2)
A
datat<-function(docid,d){
#l<-NULL
list1<-list()
for (i in docid){
a<-d[d$DocIDi %in% i,]
list1<-c(list1,a)
return(list1)
}
}
A<-datat(DocId,HIT2)
A
A$DocIDi[1]
t(A)
t(A[1])
t(A[2])
list2<-list(A$DocIDi,A$DocIDj,A$Choose)
list2
list2<-list(t(A$DocIDi),t(A$DocIDj),t(A$Choose))
list2
HIT<-read.csv("C:/Users/dell/Documents/GitHub/BradelyTerryModel/exampleHITs.csv", header=T)
datatransform<-function(HIT){
vec<-rep(1:2, 1500)
HIT<-cbind(HIT,vec)
HIT<-as.data.frame((HIT))
colnames(HIT)<-c("comparison_id" ,"document_id", "result","num")
DocIDi<-NULL
DocIDj<-NULL
Choose<-NULL
for (i in 1:nrow(HIT)){
if (HIT$num[i]==2){
DocIDj<-c(DocIDj,HIT$document_id[i])
}
else{
DocIDi<-c(DocIDi,HIT$document_id[i])
Choose<-c(Choose,HIT$result[i])
}
}
newHIT<-as.data.frame(cbind(DocIDi,DocIDj,Choose))
DocIDi<-NULL
DocIDj<-NULL
Choose<-NULL
for (i in 1:nrow(HIT)){
if (HIT$num[i]==1){
DocIDj<-c(DocIDj,HIT$document_id[i])
}
else{
DocIDi<-c(DocIDi,HIT$document_id[i])
Choose<-c(Choose,HIT$result[i])
}
}
newHIT2<-as.data.frame(cbind(DocIDi,DocIDj,Choose))
metaHIT<-rbind(newHIT,newHIT2)
return(metaHIT)
}
HIT2<-datatransform(HIT)
DocId<-unique(HIT$document_id)
DocId<-sort(DocId, decreasing = F)
Lambda<-runif(50)
lambda<-cbind(DocId,Lambda)
lambda<-as.data.frame(lambda)
data.generation<-function(lambda,n){ #n size dataset
output.lambda<-NULL #creates a template for the output dataset
for (i in 1:n){#this is a for loop for creating data points, n size dataset
lams<-sample(lambda$DocId, 2)#this randomly selects two of the lambdas at random
lambdavec<-NULL #creates a templace for extracting the lambda values
for (i in lams){
lambdavec<-c(lambdavec,lambda$Lambda[i]) #this actually extracts the lambdas
}
prob<-lambdavec[1]/(lambdavec[1]+lambdavec[2]) #this uses the lambdas in order to create a probability for selection
Choose <- sample(c(0,1), 1, replace = TRUE, prob = c(1-prob, prob))#this chooses the document with the predetermined probability
new.lambda<-cbind(lams[1],lams[2],Choose) #now building our output
output.lambda<-rbind(output.lambda, new.lambda)#row binding with the template
}
rownames(output.lambda)<-NULL #getting rid of the numbers for row name
output.lambda<-as.data.frame(output.lambda) #we do this because removing our row names made a sort of matrix
colnames(output.lambda)<-c("DocIDi","DocIDj","Choose") #Making the output like our dataset
return(output.lambda) #outputs our data
}
dataset<-data.generation(lambda,500)
#==============================================================================
#Pre-format data prior to rcpp coding
#==============================================================================
head(HIT2)
datatrans<-function(docid,dat){
outputlist<-NULL
outputlist<-as.list(outputlist)
for (i in docid){
outputlist[[i]]<-dat[dat$DocIDi %in% i,]
}
return(outputlist)
}
test1<-datatrans(DocId,HIT2)
test1[[5000]]
lambdatrans<-function(docid,lambda){
lambdalist<-NULL
lambdalist<-as.list(lambdalist)
for (i in docid){
lambdalist[[i]]<-lambda[lambda$DocId %in% i,]
}
return(lambdalist)
}
head(lambda)
test2<-lambdatrans(DocId,lambda)
test2[[4990]][,2]
class(test2)
set.seed(42)
id<-1:10
Lam<-runif(10)
lambda<-as.data.frame(cbind(id,Lam))
colnames(lambda)<-c('DocId', 'Lambda')
lam<-runif(10)
lambda1<-as.data.frame(cbind(id,.5))
colnames(lambda1)<-c('DocId', 'Lambda')
setwd("C:/Users/wooki/Dropbox/R_class/dplyr")
setwd("C:/Users/dell/Documents/GitHub/BradelyTerryModel/")
library(Rcpp)
sourceCpp('twolines.cpp')
sourceCpp('twolines.cpp')
Rcpp::sourceCpp('twolines.cpp')
setwd("C:/Users/dell/Documents/GitHub/BradelyTerryModel/")
library(Rcpp)
sourceCpp('twolines.cpp')
setwd("C:/Users/dell/Documents/GitHub/BradelyTerryModel")
sourceCpp('twolines.cpp')
library(Rcpp)
setwd("C:/Users/dell/Documents/GitHub/BradelyTerryModel")
sourceCpp('twolines.cpp')
sourceCpp('C:/Users/dell/Documents/GitHub/BradelyTerryModel/twolines.cpp')
sourceCpp('C:/Users/dell/Documents/GitHub/BradelyTerryModel/rcpp_ex.cpp')
library(Rcpp)
install.packages("Rcpp")
library(Rcpp)
sourceCpp('C:/Users/dell/Documents/GitHub/BradelyTerryModel/rcpp_ex.cpp')
DataFrame ex_fun(DataFrame x, IntegerVector ids) {
IntegerVector x_ids = x["id"]; // get the IDs in the dataframe
NumericVector val = x["val"]; // get the other vector(s) in x
IntegerVector idx; // An integer vector to store the rows to keep
int n = x_ids.size(), m = ids.size(); // Just object size variables
for ( int i = 0; i < n; ++i ) { // for every row in the dataframe
for ( int j = 0; j < m; ++j ) { // for every id in ids
if ( x_ids[i] == ids[j] ) { // for every x_id in x_ids
idx.push_back(i); // if x_id is in ids, add it to idx
}
}
}
// create a new dataframe out of each column of x,
// subsetting each vector by idx
return DataFrame::create(_["val"] = val[idx], _["id"] = x_ids[idx]);
}
>>>>>>> 30b6cf6a5d44c7517f78017d02f6a2e27068e440
