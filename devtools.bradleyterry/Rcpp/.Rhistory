subsetdata
id=3
subsetdata<-dataset[dataset$DocIDi %in% id,]#this subsets the dataset down to just the observations with the id that we are looking at
subsetdata
newlambda<-lambda[lambda$DocId %in% id,]#this extracts the specific lambda amount we want to upgrade for the purpose of the equation
newlambda
sumvec<-NULL #create null vectors to store our sum elements
lambdavec<-NULL #create null vector to extract the lambda elements we want
subsetdata$DocIDj
length(subsetdata$DocIDj)
head(subsetdata)
for(i in 1:nrow(subsetdata)){ #the purpose of thsi loop is to extract lambda j values for use in the next loop
lambdajsubset<-lambda[lambda$DocId %in% subsetdata$DocIDj[i],] #This picks out the lambda j values for each of the elements of the subset dataset
lambdavec<-c(lambdavec,lambdajsubset$Lambda) #this building the vector for use
}
lambdavec
newlambda
subsetdata$Choose
bradleyterry<-function(a,b,id,lambda,dataset){
subsetdata<-dataset[dataset$DocIDi %in% id,]#this subsets the dataset down to just the observations with the id that we are looking at
newlambda<-lambda[lambda$DocId %in% id,]#this extracts the specific DocID and lambda value we want to upgrade for the purpose of the equation
sumvec<-NULL #create null vectors to store our sum elements
lambdavec<-NULL #create null vector to extract the lambda elements we want
for(i in 1:nrow(subsetdata)){ #the purpose of thsi loop is to extract lambda j values for use in the next loop
lambdajsubset<-lambda[lambda$DocId %in% subsetdata$DocIDj[i],] #This picks out the lambda j values for each of the elements of the subset dataset
lambdavec<-c(lambdavec,lambdajsubset$Lambda) #this building the vector for use
}
for (i in 1:nrow(subsetdata)){
sumunit<-(1/(newlambda$Lambda+lambdavec[i])) #This creates the summation term unit by unit with the lambda i value and all of the respective lambda js
sumvec<-as.vector(c(sumvec,sumunit)) #this makes a vector of the summation terms
}
summationterm<-sum(sumvec) #here we sum the terms of the vector to plug into the equation
output<-(a-1+sum(subsetdata$Choose))/(b+summationterm) #this is where we finish up the equation and plug in all of our respective parts
return(output)
}
bradelyterry(1,0,3)
bradleyterry(1,0,3)
dataset
bradleyterry(1,0,3, lambda, dataset)
!lambda$DocId %in% id
bradleyterry.multid<-function(a,b,id,lambda,dataset){
updatedlambda<-NULL #creating a vector for storing the updated lambda
for (i in id){ # run loop for each vector in id
newlambda<-bradleyterry(a,b,i,lambda,dataset) #running the function above for each chosen doc id
updatedlambda<-c(updatedlambda,newlambda) #update lambda
}
lambdajsave<-lambda[!lambda$DocId %in% id,]
output<-as.data.frame(cbind(id,updatedlambda)) #bind id and updated lambda as dataframe
#output<-as.data.frame(output) #original code; moved to row above #putting the output in a format for later use
colnames(output)<-c('DocId','Lambda') #naming the outputs so they can be included right back in
return(output)
}
iterative.bt<-function(a,b,id,lambda,dataset, iterations){
for (i in 1:iterations){   # from 1 to number of iteration, the loop repeats below function
lambda<-bradleyterry.multid(a,b,id,lambda,dataset) #run the code above for one doc id, a number of times determined by user
}
return(lambda) #returns the output as the number of iterations determined by the user.
}
library(plyr)
iterative.bt(1,1,id=c(3,4,5),lambda,dataset,50)
lambda
head(dataset)
iterative.bt(1,0,id=c(3,4,5),lambda,dataset,50)
iterative.bt(1,0,id=3,lambda,dataset,50)
bradleyterry.multid(1,0,id=c(3,4), lambda, dataset)
bradleyterry.multid(1,0,id=c(3,4), lambda, dataset)
bradleyterry.multid(1,0,id=c(3,4), lambda, dataset)
bradleyterry.multid(1,0,id=c(3,4), lambda, dataset)
lambda<-bradleyterry.multid(1,0,id=c(3,4), lambda, dataset) #run the code above for one doc id, a number of times determined by user
lambda
bradleyterry.multid(1,0,id=c(3,4), lambda, dataset)
set.seed(42)
id<-1:10
Lam<-runif(10)
lambda<-as.data.frame(cbind(id,Lam))
colnames(lambda)<-c('DocId', 'Lambda')
data.generation<-function(lambda,n){ #n size dataset
output.lambda<-NULL #creates a template for the output dataset
for (i in 1:n){#this is a for loop for creating data points, n size dataset
lams<-sample(lambda$DocId, 2)#this randomly selects two of the lambdas at random
lambdavec<-NULL #creates a templace for extracting the lambda values
for (i in lams){
lambdavec<-c(lambdavec,lambda$Lambda[i]) #this actually extracts the lambdas
}
prob<-lambdavec[1]/(lambdavec[1]+lambdavec[2]) #this uses the lambdas in order to create a probability for selection
Choose <- sample(c(0,1), 1, replace = TRUE, prob = c(1-prob, prob))#this chooses the document with the predetermined probability
new.lambda<-cbind(lams[1],lams[2],Choose) #now building our output
output.lambda<-rbind(output.lambda, new.lambda)#row binding with the template
}
rownames(output.lambda)<-NULL #getting rid of the numbers for row name
output.lambda<-as.data.frame(output.lambda) #we do this because removing our row names made a sort of matrix
colnames(output.lambda)<-c("DocIDi","DocIDj","Choose") #Making the output like our dataset
return(output.lambda) #outputs our data
}
lambda1<-bradleyterry.multid(1,0,id=c(3,4), lambda, dataset) #run the code above for one doc id, a number of times determined by user
lambda1
lambda
iterative.bt(1,0,id,lambda,dataset,50)
data.generation<-function(lambda,n){ #n size dataset
output.lambda<-NULL #creates a template for the output dataset
for (i in 1:n){#this is a for loop for creating data points, n size dataset
lams<-sample(lambda$DocId, 2)#this randomly selects two of the lambdas at random
lambdavec<-NULL #creates a templace for extracting the lambda values
for (i in lams){
lambdavec<-c(lambdavec,lambda$Lambda[i]) #this actually extracts the lambdas
}
prob<-lambdavec[1]/(lambdavec[1]+lambdavec[2]) #this uses the lambdas in order to create a probability for selection
Choose <- sample(c(0,1), 1, replace = TRUE, prob = c(1-prob, prob))#this chooses the document with the predetermined probability
new.lambda<-cbind(lams[1],lams[2],Choose) #now building our output
output.lambda<-rbind(output.lambda, new.lambda)#row binding with the template
}
rownames(output.lambda)<-NULL #getting rid of the numbers for row name
output.lambda<-as.data.frame(output.lambda) #we do this because removing our row names made a sort of matrix
colnames(output.lambda)<-c("DocIDi","DocIDj","Choose") #Making the output like our dataset
return(output.lambda) #outputs our data
}
dataset<-data.generation(lambda,500)
class(dataset)
class(lambda)
library(plyr)
ddply(.data=dataset, .variables=c("DocIDi", "DocIDj"), .fun=bradleyterry(a,b,id,lambda,dataset))
ddply(.data=dataset, .variables=c("DocIDi", "DocIDj"), .fun=bradleyterry(1,0,id=(3,4),lambda,dataset))
ddply(.data=dataset, .variables=c("DocIDi", "DocIDj"), .fun=bradleyterry(1,0,id=c(3,4),lambda,dataset))
bradleyterry<-function(a,b,id,lambda,dataset){
subsetdata<-dataset[dataset$DocIDi %in% id,]#this subsets the dataset down to just the observations with the id that we are looking at
newlambda<-lambda[lambda$DocId %in% id,]#this extracts the specific DocID and lambda value we want to upgrade for the purpose of the equation
sumvec<-NULL #create null vectors to store our sum elements
lambdavec<-NULL #create null vector to extract the lambda elements we want
for(i in 1:nrow(subsetdata)){ #the purpose of thsi loop is to extract lambda j values for use in the next loop
lambdajsubset<-lambda[lambda$DocId %in% subsetdata$DocIDj[i],] #This picks out the lambda j values for each of the elements of the subset dataset
lambdavec<-c(lambdavec,lambdajsubset$Lambda) #this building the vector for use
}
for (i in 1:nrow(subsetdata)){
sumunit<-(1/(newlambda$Lambda+lambdavec[i])) #This creates the summation term unit by unit with the lambda i value and all of the respective lambda js
sumvec<-as.vector(c(sumvec,sumunit)) #this makes a vector of the summation terms
}
summationterm<-sum(sumvec) #here we sum the terms of the vector to plug into the equation
output<-(a-1+sum(subsetdata$Choose))/(b+summationterm) #this is where we finish up the equation and plug in all of our respective parts
return(output)
}
ddply(.data=dataset, .variables=c("DocIDi", "DocIDj"), .fun=bradleyterry(1,0,1,lambda,dataset))
head(dataset)
uniqueDocID<-c(unique(HIT[,2]),unique(HIT[,1]))
set.seed(13)
lambdaDocIDj<-round(runif(uniqueDocID),3)
HIT<-read.csv("C:/Users/zoeja/OneDrive/Documents/Spring2018/R/BradelyTerryModel/exampleHITs.csv", header=T)
colnames(HIT)<-c("DocIDi", "DocIDj", "Choose")
uniqueDocID<-c(unique(HIT[,2]),unique(HIT[,1]))
set.seed(13)
lambdaDocID<-round(runif(uniqueDocID),3)
lambda<-data.frame(uniqueDocID, lambda.value)
lambda.value<-round(runif(uniqueDocID),3)
set.seed(13)
lambda.value<-round(runif(uniqueDocID),3)
lambda<-data.frame(uniqueDocID, lambda.value)
colnames(lambda)<-c('DocId', 'Lambda')
head(lambda)
uniqueDocID<-c(unique(HIT[,1]),unique(HIT[,2]))
set.seed(13)
lambda.value<-round(runif(uniqueDocID),3)
lambda<-data.frame(uniqueDocID, lambda.value)
colnames(lambda)<-c('DocId', 'Lambda')
head(lambda)
lambda.df<-data.frame(uniqueDocID, lambda.value)
colnames(lambda.df)<-c('DocId', 'Lambda')
head(lambda) #check it out
head(HIT)
HIT.meta<-as.data.frame(cbind(HIT$DocIDj, HIT$DocIDi, HIT$Choose2))
head(HIT.meta)
for(i in 1:nrow(HIT)){
if(HIT$Choose[i]==0){
HIT$Choose2[i]=1
} else if(HIT$Choose[i]==1){
HIT$Choose2[i]=0
}
}
HIT.meta<-as.data.frame(cbind(HIT$DocIDj, HIT$DocIDi, HIT$Choose2))
head(HIT.meta)
colnames(HIT.meta)<-c("DocIDi", "DocIDj", "Choose")
colnames(HIT.meta)<-c("DocIDi", "DocIDj", "Choose")
head(HIT.meta,2)
HIT2<-as.data.frame(cbind(HIT$DocIDj, HIT$DocIDi, HIT$Choose2)) #HIT where j is compared to i
colnames(HIT2)<-c("DocIDi", "DocIDj", "Choose")
head(HIT2)# take a look
HIT<-HIT[,-4] #remove the "Choose2" column
metaHIT<-rbind(HIT, HIT2)
head(metaHIT)
tail(metaHIT)
metaHIT[c(501:506), ]
head(metaHIT)
metaHIT[c(501:506), ]
head(HIT)
head(newHIT)
newHIT<-as.data.frame(cbind(HIT$DocIDi,HIT$DocIDj,HIT$Choose))
colnames(newHIT)<-c("DocIDi", "DocIDj", "chosen")
head(newHIT)
for(i in 1:nrow(newHIT)){
if(newHIT$chosen[i]==0){
newHIT$chosen2[i]=1
} else if(newHIT$chosen[i]==1){
newHIT$chosen2[i]=0
}
}
sum(newHIT$chosen==newHIT$chosen2)
newHIT<-newHIT[,-4] #remove inverse row of chosen2
colnames(newHIT)<-c("DocIDi", "DocIDj", "Choose")
newHIT2<-as.data.frame(cbind(newHIT$DocIDj, newHIT$DocIDi, newHIT$chosen2))
colnames(newHIT2)<-c("DocIDi", "DocIDj", "Choose")
metaHIT1<-rbind(newHIT, newHIT2)
head(lambda.df) #check it out
id<-unique(HIT$DocIDi)
lambda<-data.frame(c(10:1),runif(10))
colnames(lambda)<-c('DocId', 'Lambda')
HIT$lambda<-runif(nrow(HIT))
head(HIT)
dat<-read.csv("C:/Users/zoeja/OneDrive/Documents/Spring2018/R/BradelyTerryModel/CombinedOutputExperiment2.csv", header = T)
HIT<-dat[,3:5]
datatransform<-function(HIT){
vec<-rep(1:2, 1500)
HIT<-cbind(HIT,vec)
HIT<-as.data.frame((HIT))
colnames(HIT)<-c("comparison_id" ,"document_id", "result","num")
DocIDi<-NULL
DocIDj<-NULL
Choose<-NULL
for (i in 1:nrow(HIT)){
if (HIT$num[i]==2){
DocIDj<-c(DocIDj,HIT$document_id[i])
}
else{
DocIDi<-c(DocIDi,HIT$document_id[i])
Choose<-c(Choose,HIT$result[i])
}
}
newHIT<-as.data.frame(cbind(DocIDi,DocIDj,Choose))
DocIDi<-NULL
DocIDj<-NULL
Choose<-NULL
for (i in 1:nrow(HIT)){
if (HIT$num[i]==1){
DocIDj<-c(DocIDj,HIT$document_id[i])
}
else{
DocIDi<-c(DocIDi,HIT$document_id[i])
Choose<-c(Choose,HIT$result[i])
}
}
newHIT2<-as.data.frame(cbind(DocIDi,DocIDj,Choose))
metaHIT<-rbind(newHIT,newHIT2)
return(metaHIT)
}
HIT2<-datatransform(HIT)
DocId<-unique(HIT$document_id)
DocId<-sort(DocId, decreasing = F)
Lambda<-runif(50)
lambda<-cbind(DocId,Lambda)
lambda<-as.data.frame(lambda)
data.generation<-function(lambda,n){ #n size dataset
output.lambda<-NULL #creates a template for the output dataset
for (i in 1:n){#this is a for loop for creating data points, n size dataset
lams<-sample(lambda$DocId, 2)#this randomly selects two of the lambdas at random
lambdavec<-NULL #creates a templace for extracting the lambda values
for (i in lams){
lambdavec<-c(lambdavec,lambda$Lambda[i]) #this actually extracts the lambdas
}
prob<-lambdavec[1]/(lambdavec[1]+lambdavec[2]) #this uses the lambdas in order to create a probability for selection
Choose <- sample(c(0,1), 1, replace = TRUE, prob = c(1-prob, prob))#this chooses the document with the predetermined probability
new.lambda<-cbind(lams[1],lams[2],Choose) #now building our output
output.lambda<-rbind(output.lambda, new.lambda)#row binding with the template
}
rownames(output.lambda)<-NULL #getting rid of the numbers for row name
output.lambda<-as.data.frame(output.lambda) #we do this because removing our row names made a sort of matrix
colnames(output.lambda)<-c("DocIDi","DocIDj","Choose") #Making the output like our dataset
return(output.lambda) #outputs our data
}
dataset<-data.generation(lambda,500)
datatrans<-function(docid,dat){
outputlist<-NULL
outputlist<-as.list(outputlist)
for (i in docid){
outputlist[[i]]<-dat[dat$DocIDi %in% i,]
}
return(outputlist)
}
test1<-datatrans(DocId,HIT2)
test1[[5000]]
lambdatrans<-function(docid,lambda){
lambdalist<-NULL
lambdalist<-as.list(lambdalist)
for (i in docid){
lambdalist[[i]]<-lambda[lambda$DocId %in% i,]
}
return(lambdalist)
}
test2<-lambdatrans(DocId,lambda)
test2[[4990]][,2]
test1
test1[[1]]
test1[[4910]]
test1[[4990]]
test1[[4990]][1]
test1[[4990]][2]
HIT2
which(HIT2$DocIDi==x)
HIT2$DocIDi
HIT2$DocIDi==5011
x<-5011
which(HIT2$DocIDi==x)
which(HIT2$DocIDi==x | HIT@$DocIDj==x)
which(HIT2$DocIDi==x | HIT$DocIDj==x)
which(HIT2$DocIDi==x)
HIT2[which(HIT2$DocIDi==x),]
thisChoos<-HIT2[which(HIT2$DocIDi==x),"Choose"]
lambda1
lambda
rownames(lambda)<-lambda$DocID
lambda
rownames(lambda)<-lambda$DocId
lambda
thisChoos<-HIT2[which(HIT2$DocIDi==x),]
HIT2[which(HIT2$DocIDi==x),]
thisChoos<-HIT2[which(HIT2$DocIDi==x),"Choose"]
HIT2[which(HIT2$DocIDi==x),]
HIT2[which(HIT2$DocIDi==x),"DocIDj"]
lambda[HIT2[which(HIT2$DocIDi==x),"DocIDj"],]
lambda[paste0(HIT2[which(HIT2$DocIDi==x),"DocIDj"]),]
thisLambda<-lambda[paste0(HIT2[which(HIT2$DocIDi==x),"DocIDj"]),]
newData<-cbind(thisChoos, thisLambda)
newData
lambdax<-lambda[paste0(x),]
lambdax
lambdax<-lambda[paste0(x),"Lambda"]
lambdax
b=1
lambdax+newData$Lambda
sum(1/lambdax+newData$Lambda))
sum(1/(lambdax+newData$Lambda))
updateLambdax<-function(newData, lambdax, a=1, b=1){
numerator<-(a-1)+sum(newData$thisChoos)
denominator<-(b+sum(1/(lambdax+newData$Lambda)))
}
updateLambdax(newData=newData, lambdax=lambdax)
updateLambdax<-function(newData, lambdax, a=1, b=1){
numerator<-(a-1)+sum(newData$thisChoos)
denominator<-(b+sum(1/(lambdax+newData$Lambda)))
return(numerator/denominator)
}
updateLambdax(newData=newData, lambdax=lambdax)
dataReorganizer<-function(x){
lambdax<-lambda[paste0(x),"Lambda"]
lambdax
thisChoos<-HIT2[which(HIT2$DocIDi==x),"Choose"]
thisLambda<-lambda[paste0(HIT2[which(HIT2$DocIDi==x),"DocIDj"]),]
newData<-cbind(thisChoos, thisLambda)
newData
}
dataReorganizer(4991)
unique(lambda$DocId)
library(plyr)
toPassToC<-lapply(unique(lambda$DocId), dataReorganizer)
dim(toPassToC)
toPassToC<-
lapply(unique(lambda$DocId), dataReorganizer)
lapply(unique(lambda$DocId), dataReorganizer)
laply(unique(lambda$DocId), dataReorganizer)
dim(toPassToC)
sapply(unique(lambda$DocId), dataReorganizer)
lapply(unique(lambda$DocId), dataReorganizer)
toPassToC<-  lapply(unique(lambda$DocId), dataReorganizer)
names(toPassToC)
names(toPassToC)<-unique(lambda$DocId)
lambda
updateLambdax<-function(allData, thisName, a=1, b=1){
lambdax<-thisName
newData<-allData[[thisName]]
numerator<-(a-1)+sum(newData$thisChoos)
denominator<-(b+sum(1/(lambdax+newData$Lambda)))
return(numerator/denominator)
}
rownames(lambda)<-lambda$DocId
lambdax<-lambda[paste0(x),"Lambda"]
lambdax
thisChoos<-HIT2[which(HIT2$DocIDi==x),"Choose"]
thisLambda<-lambda[paste0(HIT2[which(HIT2$DocIDi==x),"DocIDj"]),]
newData<-cbind(thisChoos, thisLambda)
newData
updateLambdax<-function(newData, lambdax, a=1, b=1){
numerator<-(a-1)+sum(newData$thisChoos)
denominator<-(b+sum(1/(lambdax+newData$Lambda)))
return(numerator/denominator)
}
updateLambdax(newData=newData, lambdax=lambdax)
updateLambdax(allData=toPassToC, thisName="5011")
updateLambdax2<-function(allData, thisName, a=1, b=1){
lambdax<-thisName
newData<-allData[[thisName]]
numerator<-(a-1)+sum(newData$thisChoos)
denominator<-(b+sum(1/(lambdax+newData$Lambda)))
return(numerator/denominator)
}
updateLambdax2(allData=toPassToC, thisName=)
updateLambdax2(allData=toPassToC, thisName="5011")
lambda
lambda$Lambda[thisName]
lambda$Lambda["5011"]
lambda$Lambda
lambda["5011", "Lambda"]
updateLambdax2<-function(allData, lambda, thisName, a=1, b=1){
lambdax<-lambda["5011", "Lambda"]
newData<-allData[[thisName]]
numerator<-(a-1)+sum(newData$thisChoos)
denominator<-(b+sum(1/(lambdax+newData$Lambda)))
return(numerator/denominator)
}
updateLambdax2(allData=toPassToC, lambda=lambda, thisName="5011")
sapply(paste0(unique(lambda$DocId)), Fun=updateLambdax2, lambda=lambda, allData= toPassToC )
sapply(paste0(unique(lambda$DocId)), FUN=updateLambdax2, lambda=lambda, allData= toPassToC )
dataReorganizer(5011)
toPassToC<-  lapply(unique(lambda$DocId), dataReorganizer)
names(toPassToC)<-unique(lambda$DocId)
toPassToC[["4969"]]
updateLambdax2<-function(allData, lambda, thisName, a=1, b=1){
lambdax<-lambda[thisName, "Lambda"]
newData<-allData[[thisName]]
numerator<-(a-1)+sum(newData$thisChoos)
denominator<-(b+sum(1/(lambdax+newData$Lambda)))
return(numerator/denominator)
}
updateLambdax2(allData=toPassToC, lambda=lambda, thisName="5011")
updateLambdax2(allData=toPassToC, lambda=lambda, thisName="5012")
sapply(paste0(unique(lambda$DocId)), FUN=updateLambdax2, lambda=lambda, allData= toPassToC )
rm(list=ls())
#read in data
dat<-read.csv("C:/Users/zoeja/OneDrive/Documents/Spring2018/R/BradelyTerryModel/CombinedOutputExperiment2.csv", header = T)
HIT<-dat[,3:5]
#data transformation; allows us to calculate posterior lambdas for DocIs and DocJs; this only needs to be run once, so I'm not rewriting it
datatransform<-function(HIT){
vec<-rep(1:2, 1500)
HIT<-as.data.frame(cbind(HIT,vec))
colnames(HIT)<-c("comparison_id" ,"document_id", "result","num")
DocIDi<-NULL
DocIDj<-NULL
Choose<-NULL
for (i in 1:nrow(HIT)){ #create a vector of DocIDj composed of every other document_id, the document to which the document of interest of compared
if (HIT$num[i]==2){
DocIDj<-c(DocIDj,HIT$document_id[i])
}
else{
DocIDi<-c(DocIDi,HIT$document_id[i]) #create a vector of DocIDi composed every other document id, the document of interest
Choose<-c(Choose,HIT$result[i]) #1 indicates that the document of interest won; 0 indicates that the document of interest lost
}
}
newHIT<-as.data.frame(cbind(DocIDi,DocIDj,Choose))
DocIDi<-NULL #repeat the same process, but reverse the order of comparison; this ultimately allows us to update all lambdas
DocIDj<-NULL
Choose<-NULL
for (i in 1:nrow(HIT)){
if (HIT$num[i]==1){
DocIDj<-c(DocIDj,HIT$document_id[i])
}
else{
DocIDi<-c(DocIDi,HIT$document_id[i])
Choose<-c(Choose,HIT$result[i])
}
}
newHIT2<-as.data.frame(cbind(DocIDi,DocIDj,Choose))
metaHIT<-rbind(newHIT,newHIT2)
return(metaHIT)
}
HIT2<-datatransform(HIT)
DocId<-sort(unique(HIT$document_id), decreasing=F)
lambda<- as.data.frame(cbind(DocId, runif(50)))
colnames(lambda)<-c("DocIDj", "Lambda")
Rcpp::sourceCpp("getlambda.cpp")
setwd("C:/Users/zoeja/OneDrive/Documents/Spring2018/R/BradelyTerryModel/devtools.bradleyterry/Rcpp")
Rcpp::sourceCpp("getlambda.cpp")
getlambda(lambda, DocId)
Rcpp::sourceCpp("getlambda.cpp")
getlambda(lambda, DocId)
Rcpp::sourceCpp("getlambda.cpp")
getlambda(lambda, DocId)
Rcpp::sourceCpp("subsetLambdasDF.cpp")
Rcpp::sourceCpp("subsetLambdasDF.cpp")
subsetlambda(lambda, DocId)
subsetlambdas(lambda, DocId)
lambda$DocIDj
Rcpp::sourceCpp("getlambda.cpp")
getlambda(lambda, DocId)
Rcpp::sourceCpp("getlambda.cpp")
getlambda(lambda, DocId)
Rcpp::sourceCpp("getlambda.cpp")
getlambda(lambda, DocId)
install.packages("readtate13")
install.packages("readstata13")
Rcpp::sourceCpp("subsetLambdasDF.cpp")
subsetlambdas(lambdas=lambda, DocIds=DocId)
Rcpp::sourceCpp("subsetLambdasDF.cpp")
Rcpp::sourceCpp("subsetLambdasDF.cpp")
Rcpp::sourceCpp("subsetLambdasDF.cpp")
subsetlambdas(lambdas=lambda, DocIds=DocId)
lambda$DocIDj
DocId
length(lambda["DocIDj"])
lambda$DocIDj==DocId
Rcpp::sourceCpp("getlambda.cpp")
getlambda(lambda, DocId)
lambdas$DocIDj
lambda<- as.data.frame(cbind(DocId, runif(50)))
colnames(lambda)<-c("DocIDj", "Lambda")
lambdas$DocIDj
Rcpp::sourceCpp("getlambda.cpp")
getlambda(lambda, DocId)
